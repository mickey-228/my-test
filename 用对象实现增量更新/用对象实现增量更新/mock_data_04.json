{
  "1": {
    "title": "React Hooks 基础(我被修改了）",
    "createdAt": 1704067200000,
    "content": "## React Hooks\n\nHooks 是 React 16.8 引入的新特性，允许在函数组件中使用状态和生命周期。它解决了类组件中代码复用困难、逻辑分散等问题。\n\n### 常用 Hooks\n- `useState`: 管理组件状态，返回状态值和更新函数\n- `useEffect`: 处理副作用，如数据获取、订阅、DOM 操作等\n- `useContext`: 使用上下文，避免 props 层层传递\n- `useMemo`: 性能优化，缓存计算结果\n- `useCallback`: 缓存函数引用，避免子组件不必要的重渲染\n- `useRef`: 获取 DOM 引用或保存可变值\n\n### 使用示例\n```javascript\n// useState 示例\nconst [count, setCount] = useState(0);\nconst increment = () => setCount(count + 1);\n\n// useEffect 示例\nuseEffect(() => {\n  document.title = `Count: ${count}`;\n  return () => {\n    // 清理函数\n  };\n}, [count]); // 依赖数组\n```\n\n### Hooks 规则\n1. 只能在函数组件顶层调用\n2. 不能在条件语句、循环中调用\n3. 自定义 Hooks 必须以 `use` 开头",
    "id": 1,
    "hash": "e3a26716d84875d61431aa6743106f63"
  },
  "2": {
    "title": "CSS Flexbox 布局",
    "createdAt": 1704153600000,
    "content": "## Flexbox 布局\n\nFlexbox 是一种一维布局方法，用于在容器中分配空间和对齐项目。它提供了更灵活、更强大的布局能力，特别适合处理未知或动态尺寸的元素。\n\n### 容器属性（父元素）\n- `display: flex`: 启用 flex 布局\n- `flex-direction`: 主轴方向（row, column, row-reverse, column-reverse）\n- `justify-content`: 主轴对齐方式（flex-start, center, space-between, space-around）\n- `align-items`: 交叉轴对齐方式（stretch, center, flex-start, flex-end）\n- `flex-wrap`: 是否换行（nowrap, wrap, wrap-reverse）\n- `align-content`: 多行时的交叉轴对齐\n\n### 项目属性（子元素）\n- `flex-grow`: 放大比例，默认为 0\n- `flex-shrink`: 缩小比例，默认为 1\n- `flex-basis`: 初始大小\n- `flex`: 简写属性（grow shrink basis）\n- `align-self`: 单个项目的对齐方式\n\n### 适用场景\n- 导航栏和菜单\n- 卡片布局\n- 居中元素（水平和垂直）\n- 响应式布局\n- 等分布局\n\n### 示例\n```css\n.container {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n}\n```",
    "id": 2,
    "hash": "d84f0ebb41cded9a1aa9c6d940dfe7a3"
  },
  "3": {
    "title": "JavaScript 闭包",
    "createdAt": 1704240000000,
    "content": "## 闭包（Closure）\n\n闭包是指函数能够访问其外部作用域中的变量，即使外部函数已经执行完毕。这是 JavaScript 中一个非常重要的概念，它允许函数\"记住\"并访问其词法作用域中的变量。\n\n### 特点\n- 函数嵌套：内部函数定义在外部函数内部\n- 内部函数引用外部变量：内部函数可以访问外部函数的变量和参数\n- 持久化作用域：外部函数执行后，其作用域链仍然被内部函数引用，不会被垃圾回收\n\n### 工作原理\n当函数被创建时，它会保存其词法环境（lexical environment），包括所有可访问的变量。即使外部函数执行完毕，只要内部函数仍然存在引用，外部函数的作用域就不会被销毁。\n\n### 应用场景\n- **数据私有化**: 创建私有变量，避免全局污染\n- **模块化编程**: 实现模块模式，封装功能\n- **函数工厂**: 创建具有特定配置的函数\n- **回调函数**: 在异步操作中保持上下文\n- **防抖节流**: 保存定时器 ID 等状态\n\n### 示例\n```javascript\nfunction createCounter() {\n  let count = 0; // 私有变量\n  return function() {\n    return ++count;\n  };\n}\nconst counter = createCounter();\nconsole.log(counter()); // 1\nconsole.log(counter()); // 2\n```\n\n### 注意事项\n- 闭包可能导致内存泄漏，如果不再需要应解除引用\n- 在循环中创建闭包时要注意变量捕获问题",
    "id": 3,
    "hash": "152fd7b5b7e13968311ca7fc42831cca"
  },
  "4": {
    "title": "TypeScript 类型系统",
    "createdAt": 1704326400000,
    "content": "## TypeScript 类型系统\n\nTypeScript 是 JavaScript 的超集，添加了静态类型检查。它可以在编译时发现错误，提供更好的 IDE 支持，并提高代码的可维护性。\n\n### 基础类型\n- `string`: 字符串类型\n- `number`: 数字类型（包括整数和浮点数）\n- `boolean`: 布尔值类型\n- `null` 和 `undefined`: 空值类型\n- `void`: 无返回值\n- `any`: 任意类型（应避免使用）\n- `unknown`: 类型安全的 any\n\n### 数组和对象\n```typescript\nlet arr: number[] = [1, 2, 3];\nlet obj: { name: string; age: number } = { name: 'Tom', age: 20 };\n```\n\n### 高级类型\n- **联合类型**: `string | number` - 可以是多种类型之一\n- **交叉类型**: `A & B` - 同时满足多个类型\n- **接口**: `interface` - 定义对象结构\n- **类型别名**: `type` - 为类型创建别名\n- **泛型**: `<T>` - 创建可重用的类型\n- **字面量类型**: `'success' | 'error'` - 精确的字符串值\n\n### 接口示例\n```typescript\ninterface User {\n  name: string;\n  age: number;\n  email?: string; // 可选属性\n}\n\nfunction getUser(id: number): User {\n  // ...\n}\n```\n\n### 泛型示例\n```typescript\nfunction identity<T>(arg: T): T {\n  return arg;\n}\n\nlet output = identity<string>('hello');\n```\n\n### 优势\n- 早期发现错误\n- 更好的代码提示\n- 重构更安全\n- 自文档化代码",
    "id": 4,
    "hash": "bfc8a453bdf8a45a57ae6df088b2f9ee"
  },
  "5": {
    "title": "Vue 响应式原理",
    "createdAt": 1704412800000,
    "content": "## Vue 响应式原理\n\nVue 的响应式系统是其核心特性之一，能够自动追踪数据变化并更新视图。Vue 2.x 使用 `Object.defineProperty` 实现响应式，Vue 3.x 使用 `Proxy` API。\n\n### 核心概念\n- **响应式数据**: 当数据发生变化时，自动更新依赖该数据的视图\n- **依赖收集**: 在渲染过程中追踪哪些数据被使用，建立依赖关系\n- **派发更新**: 当数据变化时，通知所有依赖该数据的组件进行更新\n- **观察者模式**: 使用观察者模式实现数据与视图的自动同步\n\n### Vue 2.x 实现方式\n```javascript\nObject.defineProperty(obj, 'key', {\n  get() {\n    // 依赖收集\n    return value;\n  },\n  set(newVal) {\n    // 派发更新\n    value = newVal;\n  }\n});\n```\n\n### Vue 3.x Proxy 实现\n```javascript\nconst reactive = new Proxy(obj, {\n  get(target, key) {\n    // 依赖收集\n    return target[key];\n  },\n  set(target, key, value) {\n    // 派发更新\n    target[key] = value;\n    return true;\n  }\n});\n```\n\n### Proxy 优势\n- 可以监听数组变化（Vue 2 需要特殊处理）\n- 可以监听对象属性的添加和删除\n- 性能更好，不需要递归遍历所有属性\n- 支持 Map、Set 等更多数据结构\n- 代码更简洁，不需要为每个属性单独定义\n\n### 响应式 API\n- `reactive()`: 创建响应式对象\n- `ref()`: 创建响应式基本类型值\n- `computed()`: 计算属性\n- `watch()`: 监听数据变化",
    "id": 5,
    "hash": "f0783f6fdfe9bb04dd39dabd21654cd0"
  },
  "6": {
    "title": "Webpack 打包原理",
    "createdAt": 1704499200000,
    "content": "## Webpack 打包原理\n\nWebpack 是一个现代 JavaScript 应用程序的静态模块打包器。它会递归地构建一个依赖关系图，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。\n\n### 核心概念\n- **Entry（入口）**: 指定 webpack 应该使用哪个模块作为构建其内部依赖图的开始\n- **Output（输出）**: 告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件\n- **Loader（加载器）**: 让 webpack 能够处理非 JavaScript 文件，将其转换为有效模块\n- **Plugin（插件）**: 用于执行范围更广的任务，如打包优化、资源管理、环境变量注入等\n- **Module（模块）**: 在模块化编程中，将程序分解成离散功能块\n- **Chunk（代码块）**: 代码分割后的产物\n\n### 工作流程\n1. **初始化**: 读取配置文件，初始化 Compiler 对象\n2. **编译**: 从入口文件开始，递归解析模块依赖\n3. **构建模块**: 使用 Loader 转换文件，解析 AST\n4. **生成依赖图**: 建立模块之间的依赖关系\n5. **输出资源**: 根据配置生成 chunk，输出到文件系统\n\n### 常用 Loader\n- `babel-loader`: 转换 ES6+ 代码\n- `css-loader`: 处理 CSS 文件\n- `file-loader`: 处理图片、字体等资源\n- `url-loader`: 将小文件转换为 base64\n\n### 常用 Plugin\n- `HtmlWebpackPlugin`: 生成 HTML 文件\n- `CleanWebpackPlugin`: 清理输出目录\n- `MiniCssExtractPlugin`: 提取 CSS 到单独文件\n- `OptimizeCssAssetsPlugin`: 压缩 CSS\n\n### 代码分割\n```javascript\n// 动态导入实现代码分割\nimport('./module').then(module => {\n  // 使用模块\n});\n```",
    "id": 6,
    "hash": "cefb9966b7a8c15bfb6fd423fb11f72f"
  },
  "7": {
    "title": "ES6 模块化",
    "createdAt": 1704585600000,
    "content": "## ES6 模块化\n\nES6 引入了原生的模块系统，使用 `import` 和 `export` 关键字。这是 JavaScript 语言层面的模块化方案，相比 CommonJS 和 AMD，具有更好的静态分析和优化能力。\n\n### 导出方式\n```javascript\n// 命名导出（Named Export）\nexport const name = 'value';\nexport function func() {}\nexport class MyClass {}\n\n// 或者统一导出\nexport { name, func, MyClass };\n\n// 默认导出（Default Export）\nexport default function() {}\nexport default class {}\n\n// 混合导出\nexport const named = 'value';\nexport default function() {}\n```\n\n### 导入方式\n```javascript\n// 命名导入\nimport { name, func } from './module';\nimport { name as myName } from './module'; // 重命名\n\n// 默认导入\nimport defaultExport from './module';\n\n// 混合导入\nimport defaultExport, { named } from './module';\n\n// 全部导入\nimport * as module from './module';\n\n// 动态导入（返回 Promise）\nimport('./module').then(module => {\n  // 使用模块\n});\n```\n\n### 与 CommonJS 的区别\n- **加载时机**: ES6 模块在编译时确定依赖，CommonJS 在运行时加载\n- **值引用**: ES6 模块输出的是值的引用，CommonJS 输出的是值的拷贝\n- **静态分析**: ES6 模块支持静态分析，可以进行树摇优化\n- **严格模式**: ES6 模块自动采用严格模式\n\n### 优势\n- **静态分析**: 编译时就能确定模块依赖关系\n- **树摇优化**: 打包工具可以移除未使用的代码\n- **循环依赖检测**: 可以在编译时发现循环依赖问题\n- **更好的 IDE 支持**: 提供更好的代码提示和跳转\n\n### 使用场景\n- 现代前端项目（React、Vue 等）\n- 需要代码分割和懒加载\n- 需要 Tree Shaking 优化\n- 浏览器原生支持（需要 type=\"module\"）",
    "id": 7,
    "hash": "7824193dc7c4e02c509ee709a430932b"
  },
  "8": {
    "title": "浏览器事件循环",
    "createdAt": 1704672000000,
    "content": "## 浏览器事件循环（Event Loop）\n\n事件循环是 JavaScript 异步执行的核心机制。它负责协调调用栈、消息队列和 Web API，确保 JavaScript 单线程能够处理异步操作。\n\n### 执行顺序\n1. **同步任务**: 立即执行，阻塞后续代码\n2. **微任务（Microtask）**: Promise.then/catch/finally、queueMicrotask、MutationObserver\n3. **宏任务（Macrotask）**: setTimeout、setInterval、I/O 操作、UI 渲染\n\n### 调用栈（Call Stack）\n- 后进先出（LIFO）的数据结构\n- 存储函数的执行上下文\n- 当函数执行完毕，会从栈顶弹出\n- 栈空时，事件循环会处理队列中的任务\n\n### 任务队列\n- **宏任务队列**: 存放宏任务，如定时器回调、事件回调\n- **微任务队列**: 存放微任务，优先级高于宏任务\n- 每次事件循环，会先执行所有微任务，再执行一个宏任务\n\n### 执行流程\n```javascript\nconsole.log('1'); // 同步\n\nsetTimeout(() => console.log('2'), 0); // 宏任务\n\nPromise.resolve().then(() => console.log('3')); // 微任务\n\nconsole.log('4'); // 同步\n\n// 输出: 1, 4, 3, 2\n```\n\n### 渲染时机\n- 浏览器会在宏任务之间进行渲染\n- 微任务会阻塞渲染，直到微任务队列清空\n- requestAnimationFrame 在渲染之前执行\n\n### 注意事项\n- 避免在微任务中创建大量微任务，可能导致页面卡顿\n- 长时间运行的同步代码会阻塞事件循环\n- 使用 Web Worker 处理 CPU 密集型任务",
    "id": 8,
    "hash": "d47bea641f73e2f676d61a424660cefa"
  },
  "9": {
    "title": "HTTP 协议基础",
    "createdAt": 1704758400000,
    "content": "## HTTP 协议基础\n\nHTTP（HyperText Transfer Protocol）是应用层协议，用于客户端和服务器之间的通信。它是 Web 的基础，定义了请求和响应的格式。\n\n### 请求方法（Methods）\n- `GET`: 获取资源，幂等，可缓存\n- `POST`: 提交数据，创建资源，非幂等\n- `PUT`: 更新资源，幂等\n- `DELETE`: 删除资源，幂等\n- `PATCH`: 部分更新资源\n- `HEAD`: 获取响应头，不返回 body\n- `OPTIONS`: 获取服务器支持的请求方法\n\n### 状态码分类\n- **2xx 成功**: \n  - `200 OK`: 请求成功\n  - `201 Created`: 资源创建成功\n  - `204 No Content`: 成功但无返回内容\n- **3xx 重定向**: \n  - `301 Moved Permanently`: 永久重定向\n  - `302 Found`: 临时重定向\n  - `304 Not Modified`: 资源未修改，使用缓存\n- **4xx 客户端错误**: \n  - `400 Bad Request`: 请求错误\n  - `401 Unauthorized`: 未授权\n  - `403 Forbidden`: 禁止访问\n  - `404 Not Found`: 资源未找到\n- **5xx 服务器错误**: \n  - `500 Internal Server Error`: 服务器内部错误\n  - `502 Bad Gateway`: 网关错误\n  - `503 Service Unavailable`: 服务不可用\n\n### 请求和响应结构\n```\n请求行: GET /index.html HTTP/1.1\n请求头: Host: example.com\n        Content-Type: application/json\n空行\n请求体: { \"key\": \"value\" }\n```\n\n### HTTP/2 特性\n- **多路复用**: 单个连接可以并行处理多个请求\n- **头部压缩**: 使用 HPACK 算法压缩头部\n- **服务器推送**: 服务器可以主动推送资源\n- **二进制分帧**: 更高效的传输格式\n- **流控制**: 更好的流量控制机制\n\n### HTTPS\n- 在 HTTP 基础上添加 SSL/TLS 加密\n- 保证数据传输的安全性\n- 使用端口 443（HTTP 使用 80）",
    "id": 9,
    "hash": "675de22e46bceb52cdab2d92c0b2dc4a"
  },
  "10": {
    "title": "前端性能优化",
    "createdAt": 1704844800000,
    "content": "## 前端性能优化\n\n前端性能优化是提升用户体验的关键，涉及资源加载、渲染性能、网络请求等多个方面。\n\n### 资源优化\n- **代码压缩和混淆**: 减小文件体积，使用 UglifyJS、Terser 等工具\n- **Tree Shaking**: 移除未使用的代码\n- **图片优化**: \n  - 使用 WebP、AVIF 等现代格式\n  - 图片懒加载（Intersection Observer）\n  - 响应式图片（srcset）\n  - 图片压缩和 CDN\n- **CDN 加速**: 使用内容分发网络加速资源加载\n- **资源预加载**: \n  - `<link rel=\"preload\">` 预加载关键资源\n  - `<link rel=\"prefetch\">` 预取未来可能需要的资源\n  - `<link rel=\"dns-prefetch\">` DNS 预解析\n\n### 渲染优化\n- **减少重排重绘**: \n  - 使用 transform 和 opacity 做动画（触发合成层）\n  - 批量 DOM 操作\n  - 使用 DocumentFragment\n- **虚拟滚动**: 只渲染可见区域的列表项\n- **代码分割**: \n  - 路由级别的代码分割\n  - 组件懒加载（React.lazy、动态 import）\n- **防抖节流**: 限制函数执行频率\n- **使用 Web Worker**: 将耗时任务移到 Worker 线程\n\n### 网络优化\n- **HTTP/2**: 多路复用、头部压缩\n- **资源压缩**: Gzip、Brotli 压缩\n- **缓存策略**: \n  - 强缓存（Cache-Control、Expires）\n  - 协商缓存（ETag、Last-Modified）\n  - Service Worker 缓存\n- **减少 HTTP 请求**: \n  - 合并文件\n  - 使用雪碧图（CSS Sprites）\n  - 内联小资源\n\n### 首屏优化\n- 关键 CSS 内联\n- 骨架屏\n- 服务端渲染（SSR）\n- 预渲染（Prerendering）\n\n### 性能监控\n- 使用 Performance API\n- Lighthouse 性能评分\n- Web Vitals 指标（LCP、FID、CLS）",
    "id": 10,
    "hash": "bf02dc1e9431e606c85562b48658208c"
  },
  "11": {
    "title": "虚拟 DOM 原理",
    "createdAt": 1704931200000,
    "content": "## 虚拟 DOM 原理\n\n虚拟 DOM（Virtual DOM）是真实 DOM 的 JavaScript 对象表示。它是 React、Vue 等框架的核心概念，通过对比虚拟 DOM 的变化来最小化真实 DOM 的操作。\n\n### 工作原理\n1. **创建虚拟 DOM 树**: 将 JSX/模板转换为虚拟 DOM 对象树\n2. **状态变化**: 当组件状态或 props 改变时，生成新的虚拟 DOM 树\n3. **Diff 算法**: 对比新旧虚拟 DOM 树，找出差异（diff）\n4. **批量更新**: 将差异应用到真实 DOM 上，批量执行更新操作\n\n### 虚拟 DOM 结构\n```javascript\n// 虚拟 DOM 节点示例\n{\n  type: 'div',\n  props: {\n    className: 'container',\n    children: [\n      { type: 'h1', props: { children: 'Hello' } },\n      { type: 'p', props: { children: 'World' } }\n    ]\n  }\n}\n```\n\n### 优势\n- **性能提升**: 减少直接操作 DOM 的次数，批量更新\n- **跨平台能力**: 虚拟 DOM 可以渲染到不同平台（Web、Native、Canvas）\n- **简化操作**: 声明式编程，不需要手动操作 DOM\n- **更好的开发体验**: 可以像操作普通对象一样操作虚拟 DOM\n\n### Diff 算法策略\n- **同层比较**: 只比较同一层级的节点，不跨层级比较\n- **key 值优化**: 使用 key 来识别节点，提高 diff 效率\n- **组件类型判断**: 如果组件类型不同，直接替换整个子树\n- **列表 diff**: 通过 key 和索引来优化列表的 diff 过程\n\n### React Fiber\nReact 16 引入 Fiber 架构，将 diff 过程拆分成多个小任务，可以中断和恢复，实现增量渲染，提高用户体验。\n\n### 注意事项\n- 虚拟 DOM 不是银弹，在某些场景下直接操作 DOM 可能更快\n- key 值应该稳定且唯一，不要使用索引作为 key（列表会变化时）\n- 过度使用虚拟 DOM 可能带来性能开销",
    "id": 11,
    "hash": "d5663c9d917aadfd6225e746c4d4f759"
  },
  "12": {
    "title": "跨域问题解决方案",
    "createdAt": 1705017600000,
    "content": "## 跨域问题解决方案\n\n跨域（Cross-Origin）是由于浏览器的同源策略（Same-Origin Policy）导致的限制。当协议、域名或端口不同时，浏览器会阻止跨域请求。\n\n### 同源策略\n同源是指协议、域名、端口三者完全相同。例如：\n- `https://example.com` 和 `http://example.com` - 协议不同，跨域\n- `https://example.com` 和 `https://api.example.com` - 域名不同，跨域\n- `https://example.com:80` 和 `https://example.com:443` - 端口不同，跨域\n\n### 解决方案\n\n#### 1. CORS（跨域资源共享）\n服务器设置响应头允许跨域：\n```\nAccess-Control-Allow-Origin: *  // 允许所有域名\nAccess-Control-Allow-Origin: https://example.com  // 允许特定域名\nAccess-Control-Allow-Methods: GET, POST, PUT\nAccess-Control-Allow-Headers: Content-Type\nAccess-Control-Allow-Credentials: true  // 允许携带 cookie\n```\n\n#### 2. JSONP\n利用 `<script>` 标签不受同源策略限制的特性：\n```javascript\nfunction jsonp(url, callback) {\n  const script = document.createElement('script');\n  script.src = `${url}?callback=${callback}`;\n  document.body.appendChild(script);\n}\n```\n**限制**: 只支持 GET 请求\n\n#### 3. 代理服务器\n开发环境使用代理，生产环境使用 Nginx 反向代理：\n```javascript\n// webpack devServer 配置\nproxy: {\n  '/api': {\n    target: 'http://localhost:3000',\n    changeOrigin: true\n  }\n}\n```\n\n#### 4. postMessage\n用于跨窗口、跨域通信：\n```javascript\n// 发送消息\nwindow.postMessage('data', 'https://target-origin.com');\n\n// 接收消息\nwindow.addEventListener('message', (event) => {\n  if (event.origin === 'https://target-origin.com') {\n    // 处理消息\n  }\n});\n```\n\n#### 5. document.domain\n适用于主域相同、子域不同的情况（已废弃）\n\n### 预检请求（Preflight）\n对于复杂请求，浏览器会先发送 OPTIONS 请求进行预检，服务器需要正确响应预检请求。\n\n### 注意事项\n- CORS 是最推荐的解决方案\n- JSONP 存在安全风险，已不推荐使用\n- 开发环境可以使用代理，生产环境建议使用 CORS",
    "id": 12,
    "hash": "df67fc1ae63da2ee5d301d3ece4a7a88"
  },
  "13": {
    "title": "前端路由实现",
    "createdAt": 1705104000000,
    "content": "## 前端路由实现\n\n前端路由通过改变 URL 而不刷新页面实现单页应用（SPA）的页面切换。它允许用户通过 URL 访问不同的视图，同时保持应用的流畅体验。\n\n### 实现方式\n\n#### 1. Hash 路由\n使用 URL 中的 `#` 符号（锚点）来实现路由：\n```javascript\n// 改变 hash\nwindow.location.hash = '/home';\n\n// 监听 hash 变化\nwindow.addEventListener('hashchange', () => {\n  const hash = window.location.hash.slice(1);\n  // 根据 hash 渲染对应组件\n});\n```\n\n**优点**: \n- 兼容性好，支持所有浏览器\n- 不需要服务器配置\n- 不会向服务器发送请求\n\n**缺点**: \n- URL 中带有 `#`，不够美观\n- 不支持 SEO\n\n#### 2. History 路由\n使用 HTML5 History API（pushState、replaceState）实现：\n```javascript\n// 改变 URL\nhistory.pushState({}, '', '/home');\n\n// 监听 popstate 事件（浏览器前进后退）\nwindow.addEventListener('popstate', (e) => {\n  const path = window.location.pathname;\n  // 根据 path 渲染对应组件\n});\n\n// 拦截链接点击\nwindow.addEventListener('click', (e) => {\n  if (e.target.tagName === 'A') {\n    e.preventDefault();\n    history.pushState({}, '', e.target.href);\n  }\n});\n```\n\n**优点**: \n- URL 美观，没有 `#`\n- 支持 SEO（配合 SSR）\n- 更符合 RESTful 规范\n\n**缺点**: \n- 需要服务器配置（所有路由返回 index.html）\n- 兼容性稍差（IE10+）\n\n### 路由库\n- **React Router**: React 生态最流行的路由库\n- **Vue Router**: Vue.js 官方路由管理器\n- **Next.js Router**: Next.js 框架内置的路由系统\n- **Reach Router**: 另一个 React 路由库（已合并到 React Router）\n\n### 路由功能\n- **嵌套路由**: 支持多级路由嵌套\n- **路由参数**: 动态路由 `/user/:id`\n- **查询参数**: `/search?q=keyword`\n- **路由守卫**: 权限控制、登录验证\n- **懒加载**: 路由级别的代码分割\n- **路由动画**: 页面切换动画\n\n### 实现示例（简单版）\n```javascript\nclass Router {\n  constructor() {\n    this.routes = {};\n    this.currentUrl = '';\n    this.init();\n  }\n  \n  route(path, callback) {\n    this.routes[path] = callback;\n  }\n  \n  init() {\n    window.addEventListener('load', this.refresh.bind(this));\n    window.addEventListener('hashchange', this.refresh.bind(this));\n  }\n  \n  refresh() {\n    this.currentUrl = location.hash.slice(1) || '/';\n    this.routes[this.currentUrl] && this.routes[this.currentUrl]();\n  }\n}\n```",
    "id": 13,
    "hash": "f6288e5a962e26c12130c14a958f3085"
  },
  "14": {
    "title": "状态管理方案",
    "createdAt": 1705190400000,
    "content": "## 状态管理方案\n\n状态管理用于管理应用中的共享状态，解决组件间数据共享和通信的问题。在大型应用中，合理的状态管理是保持代码可维护性的关键。\n\n### 常见方案\n\n#### 1. Redux\n- **特点**: 单一数据源，不可变更新，函数式编程\n- **核心概念**: Store、Action、Reducer\n- **适用场景**: 大型应用，需要时间旅行调试\n- **示例**:\n```javascript\n// Action\nconst increment = () => ({ type: 'INCREMENT' });\n\n// Reducer\nconst counter = (state = 0, action) => {\n  switch(action.type) {\n    case 'INCREMENT': return state + 1;\n    default: return state;\n  }\n};\n\n// Store\nconst store = createStore(counter);\n```\n\n#### 2. MobX\n- **特点**: 响应式状态管理，使用装饰器和观察者模式\n- **优势**: 学习曲线平缓，代码简洁\n- **适用场景**: 中小型应用，需要响应式更新\n\n#### 3. Vuex / Pinia\n- **Vuex**: Vue 2 的官方状态管理库\n- **Pinia**: Vue 3 推荐的状态管理库，更轻量\n- **特点**: 与 Vue 深度集成，支持模块化\n\n#### 4. Zustand\n- **特点**: 轻量级，API 简洁，无需 Provider\n- **优势**: 体积小，易于使用\n- **适用场景**: React 应用，需要简单状态管理\n\n#### 5. Context API（React）\n- React 内置的状态管理方案\n- 适合小规模状态共享\n- 配合 useReducer 可以管理复杂状态\n\n### 使用场景\n- **全局状态**: 用户信息、主题设置、语言配置\n- **组件间通信**: 跨层级组件数据传递\n- **数据持久化**: 本地存储、缓存管理\n- **异步状态**: API 请求状态、加载状态\n- **复杂业务逻辑**: 购物车、表单状态\n\n### Redux 三大原则\n1. **单一数据源**: 整个应用的状态存储在一个对象树中\n2. **状态只读**: 唯一改变 state 的方法就是触发 action\n3. **纯函数更新**: 使用纯函数（reducer）来描述状态如何更新\n\n### 状态管理选择建议\n- **小型应用**: Context API、Zustand\n- **中型应用**: Redux Toolkit、MobX\n- **大型应用**: Redux + 中间件（Redux-Saga、Redux-Thunk）\n- **Vue 应用**: Pinia（Vue 3）或 Vuex（Vue 2）\n\n### 最佳实践\n- 避免过度使用全局状态，优先使用组件本地状态\n- 保持状态扁平化，避免深层嵌套\n- 使用不可变更新，避免直接修改状态\n- 合理拆分状态模块，提高可维护性",
    "id": 14,
    "hash": "a6812d70802e39517649862241360111"
  },
  "15": {
    "title": "前端安全防护",
    "createdAt": 1705276800000,
    "content": "## 前端安全防护\n\n前端安全是 Web 开发中不可忽视的重要环节。了解常见的安全威胁和防护措施，可以有效保护应用和用户数据。\n\n### 常见攻击类型\n\n#### 1. XSS（跨站脚本攻击）\n攻击者注入恶意脚本到网页中，当其他用户浏览时执行。\n\n**类型**:\n- **存储型 XSS**: 恶意脚本存储在服务器（如评论、留言）\n- **反射型 XSS**: 恶意脚本通过 URL 参数反射到页面\n- **DOM 型 XSS**: 通过修改 DOM 环境执行恶意代码\n\n**防护措施**:\n- **输入验证和过滤**: 对用户输入进行严格验证\n- **输出编码**: 使用 `textContent` 而非 `innerHTML`\n- **CSP（内容安全策略）**: 限制脚本执行来源\n- **HttpOnly Cookie**: 防止 JavaScript 访问敏感 Cookie\n- **使用框架的转义机制**: React、Vue 等框架自动转义\n\n**示例**:\n```javascript\n// 危险\nel.innerHTML = userInput; // 可能执行恶意脚本\n\n// 安全\nel.textContent = userInput; // 自动转义\n```\n\n#### 2. CSRF（跨站请求伪造）\n攻击者诱导用户执行非本意的操作。\n\n**防护措施**:\n- **CSRF Token**: 服务器生成 token，客户端携带验证\n- **验证 Referer**: 检查请求来源\n- **SameSite Cookie**: 设置 Cookie 的 SameSite 属性\n- **双重 Cookie 验证**: 客户端和服务端都验证 Cookie\n\n#### 3. 点击劫持（Clickjacking）\n通过 iframe 覆盖透明层，诱导用户点击。\n\n**防护措施**:\n- **X-Frame-Options**: 设置 `DENY` 或 `SAMEORIGIN`\n- **CSP frame-ancestors**: 更灵活的 iframe 控制\n\n#### 4. SQL 注入（虽然主要是后端问题）\n前端应该避免拼接 SQL 语句，使用参数化查询。\n\n#### 5. 敏感信息泄露\n- 不要在客户端存储敏感信息（密码、密钥等）\n- 不要在代码中硬编码 API 密钥\n- 使用环境变量管理配置\n\n### 防护措施总结\n\n#### 输入处理\n- 严格验证用户输入（白名单验证）\n- 过滤和转义特殊字符\n- 限制输入长度和格式\n\n#### 输出处理\n- 对所有输出进行编码\n- 使用安全的 DOM API\n- 避免使用 `eval()`、`innerHTML` 等危险方法\n\n#### 传输安全\n- **HTTPS**: 使用加密传输\n- **HSTS**: 强制使用 HTTPS\n- **安全 Cookie**: 设置 Secure、HttpOnly、SameSite 属性\n\n#### 内容安全策略（CSP）\n```html\n<meta http-equiv=\"Content-Security-Policy\" \n      content=\"default-src 'self'; script-src 'self' 'unsafe-inline';\">\n```\n\n#### 其他安全措施\n- **依赖安全**: 定期更新依赖，检查已知漏洞\n- **代码混淆**: 保护业务逻辑（但不能完全防止）\n- **权限控制**: 前端权限验证（后端必须再次验证）\n- **日志监控**: 记录异常行为，及时发现攻击\n\n### 安全开发建议\n1. 永远不要信任客户端输入\n2. 使用成熟的安全库和框架\n3. 定期进行安全审计\n4. 关注 OWASP Top 10 安全风险\n5. 实施最小权限原则",
    "id": 15,
    "hash": "7acf9bbe0cbb6df7743ce449d6c96057"
  },
  "16": {
    "title": "CSS Grid 布局",
    "createdAt": 1705363200000,
    "content": "## CSS Grid 布局\n\nCSS Grid 是二维布局系统，可以同时处理行和列。它是 Flexbox 的补充，适合复杂的网格布局。\n\n### 基本概念\n- **Grid 容器**: 使用 `display: grid` 创建网格容器\n- **Grid 项目**: 容器内的直接子元素\n- **网格线**: 网格的分割线\n- **网格轨道**: 两条网格线之间的空间\n\n### 容器属性\n```css\n.grid-container {\n  display: grid;\n  grid-template-columns: repeat(3, 1fr);\n  grid-template-rows: auto;\n  gap: 20px;\n}\n```\n\n### 项目属性\n- `grid-column`: 指定项目占据的列\n- `grid-row`: 指定项目占据的行\n- `grid-area`: 指定项目占据的区域\n\n### 适用场景\n- 复杂的二维布局\n- 响应式网格系统\n- 卡片网格布局\n- 页面整体布局",
    "id": 16,
    "hash": "277e6d523768e7cca6c22a26107c0756"
  },
  "17": {
    "title": "Promise 和异步编程",
    "createdAt": 1705449600000,
    "content": "## Promise 和异步编程\n\nPromise 是 JavaScript 中处理异步操作的对象，它代表一个异步操作的最终完成或失败。\n\n### 基本用法\n```javascript\nconst promise = new Promise((resolve, reject) => {\n  // 异步操作\n  if (success) {\n    resolve(value);\n  } else {\n    reject(error);\n  }\n});\n\npromise.then(value => {\n  // 成功处理\n}).catch(error => {\n  // 错误处理\n});\n```\n\n### Promise 方法\n- `Promise.all()`: 所有 Promise 都成功\n- `Promise.race()`: 第一个完成的 Promise\n- `Promise.allSettled()`: 等待所有 Promise 完成\n- `Promise.any()`: 第一个成功的 Promise\n\n### async/await\n```javascript\nasync function fetchData() {\n  try {\n    const data = await fetch(url);\n    return data.json();\n  } catch (error) {\n    console.error(error);\n  }\n}\n```\n\n### 优势\n- 避免回调地狱\n- 更好的错误处理\n- 链式调用\n- 代码更易读",
    "id": 17,
    "hash": "fb00a13801dbc8a6e4662a2839c56682"
  },
  "18": {
    "title": "JavaScript 原型链",
    "createdAt": 1705536000000,
    "content": "## JavaScript 原型链\n\n原型链是 JavaScript 实现继承的机制。每个对象都有一个指向其原型对象的内部链接。\n\n### 原型对象\n```javascript\nfunction Person(name) {\n  this.name = name;\n}\n\nPerson.prototype.sayHello = function() {\n  console.log(`Hello, I am ${this.name}`);\n};\n\nconst person = new Person(\"Alice\");\nperson.sayHello(); // 通过原型链访问\n```\n\n### 原型链查找\n1. 对象自身属性\n2. 对象的 `__proto__` 指向的原型\n3. 原型的原型，直到 `Object.prototype`\n4. `Object.prototype.__proto__` 为 `null`\n\n### 继承实现\n```javascript\nfunction Student(name, grade) {\n  Person.call(this, name);\n  this.grade = grade;\n}\n\nStudent.prototype = Object.create(Person.prototype);\nStudent.prototype.constructor = Student;\n```\n\n### ES6 Class\n```javascript\nclass Person {\n  constructor(name) {\n    this.name = name;\n  }\n  sayHello() {\n    console.log(`Hello, I am ${this.name}`);\n  }\n}\n```\n\n### 注意事项\n- 理解原型链有助于理解 JavaScript 继承\n- 避免修改内置对象的原型\n- 使用 `Object.create()` 创建对象",
    "id": 18,
    "hash": "cd6fe684cdb3edf3c02bfca2092998bf"
  },
  "19": {
    "title": "防抖和节流",
    "createdAt": 1705622400000,
    "content": "## 防抖和节流\n\n防抖（debounce）和节流（throttle）是限制函数执行频率的两种技术。\n\n### 防抖（Debounce）\n在事件被触发 n 秒后再执行回调，如果在这 n 秒内又被触发，则重新计时。\n\n```javascript\nfunction debounce(func, delay) {\n  let timeoutId;\n  return function(...args) {\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(() => func.apply(this, args), delay);\n  };\n}\n\n// 使用\nconst handleInput = debounce((e) => {\n  console.log(e.target.value);\n}, 300);\n```\n\n### 节流（Throttle）\n规定在一个单位时间内，只能触发一次函数。\n\n```javascript\nfunction throttle(func, delay) {\n  let lastTime = 0;\n  return function(...args) {\n    const now = Date.now();\n    if (now - lastTime >= delay) {\n      lastTime = now;\n      func.apply(this, args);\n    }\n  };\n}\n```\n\n### 使用场景\n- **防抖**: 搜索框输入、窗口 resize\n- **节流**: 滚动事件、鼠标移动\n\n### React Hooks 实现\n```javascript\nfunction useDebounce(value, delay) {\n  const [debouncedValue, setDebouncedValue] = useState(value);\n  useEffect(() => {\n    const handler = setTimeout(() => setDebouncedValue(value), delay);\n    return () => clearTimeout(handler);\n  }, [value, delay]);\n  return debouncedValue;\n}\n```",
    "id": 19,
    "hash": "14efde52a99722a523ff2bf96f870dc0"
  },
  "20": {
    "title": "CSS 变量（Custom Properties）",
    "createdAt": 1705708800000,
    "content": "## CSS 变量（Custom Properties）\n\nCSS 变量允许在样式表中定义可重用的值，提高样式的可维护性。\n\n### 定义变量\n```css\n:root {\n  --primary-color: #3498db;\n  --secondary-color: #2ecc71;\n  --font-size-base: 16px;\n  --spacing-unit: 8px;\n}\n```\n\n### 使用变量\n```css\n.button {\n  background-color: var(--primary-color);\n  font-size: var(--font-size-base);\n  padding: calc(var(--spacing-unit) * 2);\n}\n```\n\n### JavaScript 操作\n```javascript\n// 获取变量值\nconst primaryColor = getComputedStyle(document.documentElement)\n  .getPropertyValue(\"--primary-color\");\n\n// 设置变量值\ndocument.documentElement.style.setProperty(\"--primary-color\", \"#ff0000\");\n```\n\n### 优势\n- 主题切换\n- 动态样式\n- 减少重复代码\n- 易于维护\n\n### 作用域\n- `:root`: 全局作用域\n- 元素选择器: 局部作用域\n- 继承性: 子元素可以继承父元素的变量",
    "id": 20,
    "hash": "1e9b9312159fce2450f7eca0dfd087fe"
  },
  "21": {
    "title": "React 组件生命周期",
    "createdAt": 1705795200000,
    "content": "## React 组件生命周期\n\nReact 组件的生命周期分为三个阶段：挂载、更新和卸载。\n\n### 类组件生命周期\n```javascript\nclass MyComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    // 初始化状态\n  }\n  \n  componentDidMount() {\n    // 组件挂载后\n  }\n  \n  componentDidUpdate(prevProps, prevState) {\n    // 组件更新后\n  }\n  \n  componentWillUnmount() {\n    // 组件卸载前\n  }\n}\n```\n\n### 函数组件等效\n```javascript\nuseEffect(() => {\n  // componentDidMount + componentDidUpdate\n  return () => {\n    // componentWillUnmount\n  };\n}, [dependencies]);\n```\n\n### 生命周期阶段\n- **挂载**: constructor → render → componentDidMount\n- **更新**: render → componentDidUpdate\n- **卸载**: componentWillUnmount\n\n### 注意事项\n- 函数组件使用 Hooks 替代生命周期\n- 避免在 render 中执行副作用\n- 及时清理订阅和定时器",
    "id": 21,
    "hash": "04ec53a60c3246ce85abd7f9f7aace21"
  },
  "22": {
    "title": "Vue 组件通信",
    "createdAt": 1705881600000,
    "content": "## Vue 组件通信\n\nVue 组件间有多种通信方式，适用于不同的场景。\n\n### Props 和 Events\n```vue\n<!-- 父组件 -->\n<ChildComponent :data=\"parentData\" @update=\"handleUpdate\" />\n\n<!-- 子组件 -->\n<template>\n  <div @click=\"$emit('update', newData)\">\n    {{ data }}\n  </div>\n</template>\n<script>\nexport default {\n  props: ['data'],\n  emits: ['update']\n}\n</script>\n```\n\n### provide/inject\n```javascript\n// 祖先组件\nprovide() {\n  return {\n    theme: this.theme\n  }\n}\n\n// 后代组件\ninject: ['theme']\n```\n\n### Vuex/Pinia\n- 全局状态管理\n- 跨组件共享数据\n\n### 事件总线（已废弃）\n- 使用全局事件总线\n- Vue 3 推荐使用 mitt 库\n\n### 最佳实践\n- 父子组件用 props/events\n- 跨层级用 provide/inject\n- 全局状态用状态管理",
    "id": 22,
    "hash": "662b95d901fc5a20a891a18e05170d01"
  },
  "23": {
    "title": "Babel 转译原理",
    "createdAt": 1705968000000,
    "content": "## Babel 转译原理\n\nBabel 是一个 JavaScript 编译器，将 ES6+ 代码转换为向后兼容的 JavaScript 版本。\n\n### 工作流程\n1. **解析（Parse）**: 将代码转换为 AST\n2. **转换（Transform）**: 对 AST 进行操作\n3. **生成（Generate）**: 将 AST 转换为代码\n\n### 核心概念\n- **AST（抽象语法树）**: 代码的树形表示\n- **Plugin**: 转换规则\n- **Preset**: 插件集合\n\n### 配置示例\n```json\n{\n  \"presets\": [\"@babel/preset-env\"],\n  \"plugins\": [\"@babel/plugin-proposal-class-properties\"]\n}\n```\n\n### 常用 Preset\n- `@babel/preset-env`: 根据目标环境转换\n- `@babel/preset-react`: React 语法转换\n- `@babel/preset-typescript`: TypeScript 转换\n\n### Polyfill\n- `@babel/polyfill`: 已废弃\n- `core-js`: 提供 polyfill\n- `regenerator-runtime`: async/await 支持",
    "id": 23,
    "hash": "63f4cbdd31a820666932f992455f4e28"
  },
  "24": {
    "title": "ESLint 代码检查",
    "createdAt": 1706054400000,
    "content": "## ESLint 代码检查\n\nESLint 是一个可插拔的 JavaScript 代码检查工具，用于发现和修复代码问题。\n\n### 配置文件\n```json\n{\n  \"extends\": [\"eslint:recommended\"],\n  \"rules\": {\n    \"no-console\": \"warn\",\n    \"no-unused-vars\": \"error\"\n  }\n}\n```\n\n### 常用规则\n- `no-console`: 禁止使用 console\n- `no-unused-vars`: 禁止未使用的变量\n- `eqeqeq`: 要求使用 === 和 !==\n- `semi`: 要求或禁止分号\n\n### 与 Prettier 集成\n```json\n{\n  \"extends\": [\n    \"eslint:recommended\",\n    \"plugin:prettier/recommended\"\n  ]\n}\n```\n\n### 优势\n- 统一代码风格\n- 提前发现错误\n- 提高代码质量\n- 团队协作规范",
    "id": 24,
    "hash": "1d8a3995213df3b3bf5a10fdc7f75556"
  },
  "25": {
    "title": "Git 工作流",
    "createdAt": 1706140800000,
    "content": "## Git 工作流\n\nGit 是分布式版本控制系统，用于跟踪代码变更。\n\n### 基本命令\n```bash\ngit add .          # 暂存更改\ngit commit -m \"msg\" # 提交更改\ngit push           # 推送到远程\ngit pull           # 拉取更新\ngit branch         # 查看分支\ngit merge          # 合并分支\n```\n\n### 工作流模型\n- **Git Flow**: 功能分支、发布分支\n- **GitHub Flow**: 简化的工作流\n- **GitLab Flow**: 带环境分支\n\n### 最佳实践\n- 频繁提交小改动\n- 写清晰的提交信息\n- 使用分支开发\n- 代码审查\n\n### 常用场景\n- 功能开发: feature 分支\n- 修复 bug: hotfix 分支\n- 发布版本: release 分支",
    "id": 25,
    "hash": "f6f9af3028ddb40a0a69a4043412df1b"
  },
  "26": {
    "title": "CSS Grid 布局 (2)",
    "createdAt": 1706227200000,
    "content": "## CSS Grid 布局\n\nCSS Grid 是二维布局系统，可以同时处理行和列。它是 Flexbox 的补充，适合复杂的网格布局。\n\n### 基本概念\n- **Grid 容器**: 使用 `display: grid` 创建网格容器\n- **Grid 项目**: 容器内的直接子元素\n- **网格线**: 网格的分割线\n- **网格轨道**: 两条网格线之间的空间\n\n### 容器属性\n```css\n.grid-container {\n  display: grid;\n  grid-template-columns: repeat(3, 1fr);\n  grid-template-rows: auto;\n  gap: 20px;\n}\n```\n\n### 项目属性\n- `grid-column`: 指定项目占据的列\n- `grid-row`: 指定项目占据的行\n- `grid-area`: 指定项目占据的区域\n\n### 适用场景\n- 复杂的二维布局\n- 响应式网格系统\n- 卡片网格布局\n- 页面整体布局",
    "id": 26,
    "hash": "66c3812c2de5e78ca2d63ab9a0b15a9e"
  },
  "27": {
    "title": "Promise 和异步编程 (2)",
    "createdAt": 1706313600000,
    "content": "## Promise 和异步编程\n\nPromise 是 JavaScript 中处理异步操作的对象，它代表一个异步操作的最终完成或失败。\n\n### 基本用法\n```javascript\nconst promise = new Promise((resolve, reject) => {\n  // 异步操作\n  if (success) {\n    resolve(value);\n  } else {\n    reject(error);\n  }\n});\n\npromise.then(value => {\n  // 成功处理\n}).catch(error => {\n  // 错误处理\n});\n```\n\n### Promise 方法\n- `Promise.all()`: 所有 Promise 都成功\n- `Promise.race()`: 第一个完成的 Promise\n- `Promise.allSettled()`: 等待所有 Promise 完成\n- `Promise.any()`: 第一个成功的 Promise\n\n### async/await\n```javascript\nasync function fetchData() {\n  try {\n    const data = await fetch(url);\n    return data.json();\n  } catch (error) {\n    console.error(error);\n  }\n}\n```\n\n### 优势\n- 避免回调地狱\n- 更好的错误处理\n- 链式调用\n- 代码更易读",
    "id": 27,
    "hash": "25b3322dc295a83c886090fbd87cbdf1"
  },
  "28": {
    "title": "JavaScript 原型链 (2)",
    "createdAt": 1706400000000,
    "content": "## JavaScript 原型链\n\n原型链是 JavaScript 实现继承的机制。每个对象都有一个指向其原型对象的内部链接。\n\n### 原型对象\n```javascript\nfunction Person(name) {\n  this.name = name;\n}\n\nPerson.prototype.sayHello = function() {\n  console.log(`Hello, I am ${this.name}`);\n};\n\nconst person = new Person(\"Alice\");\nperson.sayHello(); // 通过原型链访问\n```\n\n### 原型链查找\n1. 对象自身属性\n2. 对象的 `__proto__` 指向的原型\n3. 原型的原型，直到 `Object.prototype`\n4. `Object.prototype.__proto__` 为 `null`\n\n### 继承实现\n```javascript\nfunction Student(name, grade) {\n  Person.call(this, name);\n  this.grade = grade;\n}\n\nStudent.prototype = Object.create(Person.prototype);\nStudent.prototype.constructor = Student;\n```\n\n### ES6 Class\n```javascript\nclass Person {\n  constructor(name) {\n    this.name = name;\n  }\n  sayHello() {\n    console.log(`Hello, I am ${this.name}`);\n  }\n}\n```\n\n### 注意事项\n- 理解原型链有助于理解 JavaScript 继承\n- 避免修改内置对象的原型\n- 使用 `Object.create()` 创建对象",
    "id": 28,
    "hash": "6ac62bbf15dc0e6c379d9cee5746135b"
  },
  "29": {
    "title": "防抖和节流 (2)",
    "createdAt": 1706486400000,
    "content": "## 防抖和节流\n\n防抖（debounce）和节流（throttle）是限制函数执行频率的两种技术。\n\n### 防抖（Debounce）\n在事件被触发 n 秒后再执行回调，如果在这 n 秒内又被触发，则重新计时。\n\n```javascript\nfunction debounce(func, delay) {\n  let timeoutId;\n  return function(...args) {\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(() => func.apply(this, args), delay);\n  };\n}\n\n// 使用\nconst handleInput = debounce((e) => {\n  console.log(e.target.value);\n}, 300);\n```\n\n### 节流（Throttle）\n规定在一个单位时间内，只能触发一次函数。\n\n```javascript\nfunction throttle(func, delay) {\n  let lastTime = 0;\n  return function(...args) {\n    const now = Date.now();\n    if (now - lastTime >= delay) {\n      lastTime = now;\n      func.apply(this, args);\n    }\n  };\n}\n```\n\n### 使用场景\n- **防抖**: 搜索框输入、窗口 resize\n- **节流**: 滚动事件、鼠标移动\n\n### React Hooks 实现\n```javascript\nfunction useDebounce(value, delay) {\n  const [debouncedValue, setDebouncedValue] = useState(value);\n  useEffect(() => {\n    const handler = setTimeout(() => setDebouncedValue(value), delay);\n    return () => clearTimeout(handler);\n  }, [value, delay]);\n  return debouncedValue;\n}\n```",
    "id": 29,
    "hash": "ad9b166fd82fbddd5a7d9e4ae988c254"
  },
  "30": {
    "title": "CSS 变量（Custom Properties） (2)",
    "createdAt": 1706572800000,
    "content": "## CSS 变量（Custom Properties）\n\nCSS 变量允许在样式表中定义可重用的值，提高样式的可维护性。\n\n### 定义变量\n```css\n:root {\n  --primary-color: #3498db;\n  --secondary-color: #2ecc71;\n  --font-size-base: 16px;\n  --spacing-unit: 8px;\n}\n```\n\n### 使用变量\n```css\n.button {\n  background-color: var(--primary-color);\n  font-size: var(--font-size-base);\n  padding: calc(var(--spacing-unit) * 2);\n}\n```\n\n### JavaScript 操作\n```javascript\n// 获取变量值\nconst primaryColor = getComputedStyle(document.documentElement)\n  .getPropertyValue(\"--primary-color\");\n\n// 设置变量值\ndocument.documentElement.style.setProperty(\"--primary-color\", \"#ff0000\");\n```\n\n### 优势\n- 主题切换\n- 动态样式\n- 减少重复代码\n- 易于维护\n\n### 作用域\n- `:root`: 全局作用域\n- 元素选择器: 局部作用域\n- 继承性: 子元素可以继承父元素的变量",
    "id": 30,
    "hash": "81bb21abe62a0d85918d611abc30669c"
  },
  "31": {
    "title": "React 组件生命周期 (2)",
    "createdAt": 1706659200000,
    "content": "## React 组件生命周期\n\nReact 组件的生命周期分为三个阶段：挂载、更新和卸载。\n\n### 类组件生命周期\n```javascript\nclass MyComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    // 初始化状态\n  }\n  \n  componentDidMount() {\n    // 组件挂载后\n  }\n  \n  componentDidUpdate(prevProps, prevState) {\n    // 组件更新后\n  }\n  \n  componentWillUnmount() {\n    // 组件卸载前\n  }\n}\n```\n\n### 函数组件等效\n```javascript\nuseEffect(() => {\n  // componentDidMount + componentDidUpdate\n  return () => {\n    // componentWillUnmount\n  };\n}, [dependencies]);\n```\n\n### 生命周期阶段\n- **挂载**: constructor → render → componentDidMount\n- **更新**: render → componentDidUpdate\n- **卸载**: componentWillUnmount\n\n### 注意事项\n- 函数组件使用 Hooks 替代生命周期\n- 避免在 render 中执行副作用\n- 及时清理订阅和定时器",
    "id": 31,
    "hash": "ff6e5d16127b7ed86ad24155d1f84f74"
  },
  "32": {
    "title": "Vue 组件通信 (2)",
    "createdAt": 1706745600000,
    "content": "## Vue 组件通信\n\nVue 组件间有多种通信方式，适用于不同的场景。\n\n### Props 和 Events\n```vue\n<!-- 父组件 -->\n<ChildComponent :data=\"parentData\" @update=\"handleUpdate\" />\n\n<!-- 子组件 -->\n<template>\n  <div @click=\"$emit('update', newData)\">\n    {{ data }}\n  </div>\n</template>\n<script>\nexport default {\n  props: ['data'],\n  emits: ['update']\n}\n</script>\n```\n\n### provide/inject\n```javascript\n// 祖先组件\nprovide() {\n  return {\n    theme: this.theme\n  }\n}\n\n// 后代组件\ninject: ['theme']\n```\n\n### Vuex/Pinia\n- 全局状态管理\n- 跨组件共享数据\n\n### 事件总线（已废弃）\n- 使用全局事件总线\n- Vue 3 推荐使用 mitt 库\n\n### 最佳实践\n- 父子组件用 props/events\n- 跨层级用 provide/inject\n- 全局状态用状态管理",
    "id": 32,
    "hash": "432df8ed4ea69e9b576b5c4eeaa596b6"
  },
  "33": {
    "title": "Babel 转译原理 (2)",
    "createdAt": 1706832000000,
    "content": "## Babel 转译原理\n\nBabel 是一个 JavaScript 编译器，将 ES6+ 代码转换为向后兼容的 JavaScript 版本。\n\n### 工作流程\n1. **解析（Parse）**: 将代码转换为 AST\n2. **转换（Transform）**: 对 AST 进行操作\n3. **生成（Generate）**: 将 AST 转换为代码\n\n### 核心概念\n- **AST（抽象语法树）**: 代码的树形表示\n- **Plugin**: 转换规则\n- **Preset**: 插件集合\n\n### 配置示例\n```json\n{\n  \"presets\": [\"@babel/preset-env\"],\n  \"plugins\": [\"@babel/plugin-proposal-class-properties\"]\n}\n```\n\n### 常用 Preset\n- `@babel/preset-env`: 根据目标环境转换\n- `@babel/preset-react`: React 语法转换\n- `@babel/preset-typescript`: TypeScript 转换\n\n### Polyfill\n- `@babel/polyfill`: 已废弃\n- `core-js`: 提供 polyfill\n- `regenerator-runtime`: async/await 支持",
    "id": 33,
    "hash": "36ecc47ed7a8ecc1b7e3b627a66f87e4"
  },
  "34": {
    "title": "ESLint 代码检查 (2)",
    "createdAt": 1706918400000,
    "content": "## ESLint 代码检查\n\nESLint 是一个可插拔的 JavaScript 代码检查工具，用于发现和修复代码问题。\n\n### 配置文件\n```json\n{\n  \"extends\": [\"eslint:recommended\"],\n  \"rules\": {\n    \"no-console\": \"warn\",\n    \"no-unused-vars\": \"error\"\n  }\n}\n```\n\n### 常用规则\n- `no-console`: 禁止使用 console\n- `no-unused-vars`: 禁止未使用的变量\n- `eqeqeq`: 要求使用 === 和 !==\n- `semi`: 要求或禁止分号\n\n### 与 Prettier 集成\n```json\n{\n  \"extends\": [\n    \"eslint:recommended\",\n    \"plugin:prettier/recommended\"\n  ]\n}\n```\n\n### 优势\n- 统一代码风格\n- 提前发现错误\n- 提高代码质量\n- 团队协作规范",
    "id": 34,
    "hash": "7f5d1a0d425f6335e7044ff36b605416"
  },
  "35": {
    "title": "Git 工作流 (2)",
    "createdAt": 1707004800000,
    "content": "## Git 工作流\n\nGit 是分布式版本控制系统，用于跟踪代码变更。\n\n### 基本命令\n```bash\ngit add .          # 暂存更改\ngit commit -m \"msg\" # 提交更改\ngit push           # 推送到远程\ngit pull           # 拉取更新\ngit branch         # 查看分支\ngit merge          # 合并分支\n```\n\n### 工作流模型\n- **Git Flow**: 功能分支、发布分支\n- **GitHub Flow**: 简化的工作流\n- **GitLab Flow**: 带环境分支\n\n### 最佳实践\n- 频繁提交小改动\n- 写清晰的提交信息\n- 使用分支开发\n- 代码审查\n\n### 常用场景\n- 功能开发: feature 分支\n- 修复 bug: hotfix 分支\n- 发布版本: release 分支",
    "id": 35,
    "hash": "3a388621af6595c78bd27ad709c12c5b"
  },
  "36": {
    "title": "CSS Grid 布局 (3)",
    "createdAt": 1707091200000,
    "content": "## CSS Grid 布局\n\nCSS Grid 是二维布局系统，可以同时处理行和列。它是 Flexbox 的补充，适合复杂的网格布局。\n\n### 基本概念\n- **Grid 容器**: 使用 `display: grid` 创建网格容器\n- **Grid 项目**: 容器内的直接子元素\n- **网格线**: 网格的分割线\n- **网格轨道**: 两条网格线之间的空间\n\n### 容器属性\n```css\n.grid-container {\n  display: grid;\n  grid-template-columns: repeat(3, 1fr);\n  grid-template-rows: auto;\n  gap: 20px;\n}\n```\n\n### 项目属性\n- `grid-column`: 指定项目占据的列\n- `grid-row`: 指定项目占据的行\n- `grid-area`: 指定项目占据的区域\n\n### 适用场景\n- 复杂的二维布局\n- 响应式网格系统\n- 卡片网格布局\n- 页面整体布局",
    "id": 36,
    "hash": "fb71629c5d8e383e994b51685707e6b8"
  },
  "37": {
    "title": "Promise 和异步编程 (3)",
    "createdAt": 1707177600000,
    "content": "## Promise 和异步编程\n\nPromise 是 JavaScript 中处理异步操作的对象，它代表一个异步操作的最终完成或失败。\n\n### 基本用法\n```javascript\nconst promise = new Promise((resolve, reject) => {\n  // 异步操作\n  if (success) {\n    resolve(value);\n  } else {\n    reject(error);\n  }\n});\n\npromise.then(value => {\n  // 成功处理\n}).catch(error => {\n  // 错误处理\n});\n```\n\n### Promise 方法\n- `Promise.all()`: 所有 Promise 都成功\n- `Promise.race()`: 第一个完成的 Promise\n- `Promise.allSettled()`: 等待所有 Promise 完成\n- `Promise.any()`: 第一个成功的 Promise\n\n### async/await\n```javascript\nasync function fetchData() {\n  try {\n    const data = await fetch(url);\n    return data.json();\n  } catch (error) {\n    console.error(error);\n  }\n}\n```\n\n### 优势\n- 避免回调地狱\n- 更好的错误处理\n- 链式调用\n- 代码更易读",
    "id": 37,
    "hash": "4ed095e08a8e30a04e2dfa0d09704a1e"
  },
  "38": {
    "title": "JavaScript 原型链 (3)",
    "createdAt": 1707264000000,
    "content": "## JavaScript 原型链\n\n原型链是 JavaScript 实现继承的机制。每个对象都有一个指向其原型对象的内部链接。\n\n### 原型对象\n```javascript\nfunction Person(name) {\n  this.name = name;\n}\n\nPerson.prototype.sayHello = function() {\n  console.log(`Hello, I am ${this.name}`);\n};\n\nconst person = new Person(\"Alice\");\nperson.sayHello(); // 通过原型链访问\n```\n\n### 原型链查找\n1. 对象自身属性\n2. 对象的 `__proto__` 指向的原型\n3. 原型的原型，直到 `Object.prototype`\n4. `Object.prototype.__proto__` 为 `null`\n\n### 继承实现\n```javascript\nfunction Student(name, grade) {\n  Person.call(this, name);\n  this.grade = grade;\n}\n\nStudent.prototype = Object.create(Person.prototype);\nStudent.prototype.constructor = Student;\n```\n\n### ES6 Class\n```javascript\nclass Person {\n  constructor(name) {\n    this.name = name;\n  }\n  sayHello() {\n    console.log(`Hello, I am ${this.name}`);\n  }\n}\n```\n\n### 注意事项\n- 理解原型链有助于理解 JavaScript 继承\n- 避免修改内置对象的原型\n- 使用 `Object.create()` 创建对象",
    "id": 38,
    "hash": "3ec2ace9f9434739d005e2033b4274cb"
  },
  "39": {
    "title": "防抖和节流 (3)",
    "createdAt": 1707350400000,
    "content": "## 防抖和节流\n\n防抖（debounce）和节流（throttle）是限制函数执行频率的两种技术。\n\n### 防抖（Debounce）\n在事件被触发 n 秒后再执行回调，如果在这 n 秒内又被触发，则重新计时。\n\n```javascript\nfunction debounce(func, delay) {\n  let timeoutId;\n  return function(...args) {\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(() => func.apply(this, args), delay);\n  };\n}\n\n// 使用\nconst handleInput = debounce((e) => {\n  console.log(e.target.value);\n}, 300);\n```\n\n### 节流（Throttle）\n规定在一个单位时间内，只能触发一次函数。\n\n```javascript\nfunction throttle(func, delay) {\n  let lastTime = 0;\n  return function(...args) {\n    const now = Date.now();\n    if (now - lastTime >= delay) {\n      lastTime = now;\n      func.apply(this, args);\n    }\n  };\n}\n```\n\n### 使用场景\n- **防抖**: 搜索框输入、窗口 resize\n- **节流**: 滚动事件、鼠标移动\n\n### React Hooks 实现\n```javascript\nfunction useDebounce(value, delay) {\n  const [debouncedValue, setDebouncedValue] = useState(value);\n  useEffect(() => {\n    const handler = setTimeout(() => setDebouncedValue(value), delay);\n    return () => clearTimeout(handler);\n  }, [value, delay]);\n  return debouncedValue;\n}\n```",
    "id": 39,
    "hash": "89e213dbe5f8c74d31f2a3a5a3d86255"
  },
  "40": {
    "title": "CSS 变量（Custom Properties） (3)",
    "createdAt": 1707436800000,
    "content": "## CSS 变量（Custom Properties）\n\nCSS 变量允许在样式表中定义可重用的值，提高样式的可维护性。\n\n### 定义变量\n```css\n:root {\n  --primary-color: #3498db;\n  --secondary-color: #2ecc71;\n  --font-size-base: 16px;\n  --spacing-unit: 8px;\n}\n```\n\n### 使用变量\n```css\n.button {\n  background-color: var(--primary-color);\n  font-size: var(--font-size-base);\n  padding: calc(var(--spacing-unit) * 2);\n}\n```\n\n### JavaScript 操作\n```javascript\n// 获取变量值\nconst primaryColor = getComputedStyle(document.documentElement)\n  .getPropertyValue(\"--primary-color\");\n\n// 设置变量值\ndocument.documentElement.style.setProperty(\"--primary-color\", \"#ff0000\");\n```\n\n### 优势\n- 主题切换\n- 动态样式\n- 减少重复代码\n- 易于维护\n\n### 作用域\n- `:root`: 全局作用域\n- 元素选择器: 局部作用域\n- 继承性: 子元素可以继承父元素的变量",
    "id": 40,
    "hash": "b792177b3d1440157cc067cc40c49561"
  },
  "41": {
    "title": "React 组件生命周期 (3)",
    "createdAt": 1707523200000,
    "content": "## React 组件生命周期\n\nReact 组件的生命周期分为三个阶段：挂载、更新和卸载。\n\n### 类组件生命周期\n```javascript\nclass MyComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    // 初始化状态\n  }\n  \n  componentDidMount() {\n    // 组件挂载后\n  }\n  \n  componentDidUpdate(prevProps, prevState) {\n    // 组件更新后\n  }\n  \n  componentWillUnmount() {\n    // 组件卸载前\n  }\n}\n```\n\n### 函数组件等效\n```javascript\nuseEffect(() => {\n  // componentDidMount + componentDidUpdate\n  return () => {\n    // componentWillUnmount\n  };\n}, [dependencies]);\n```\n\n### 生命周期阶段\n- **挂载**: constructor → render → componentDidMount\n- **更新**: render → componentDidUpdate\n- **卸载**: componentWillUnmount\n\n### 注意事项\n- 函数组件使用 Hooks 替代生命周期\n- 避免在 render 中执行副作用\n- 及时清理订阅和定时器",
    "id": 41,
    "hash": "902e0859db04426205b0d033bedf60a3"
  },
  "42": {
    "title": "Vue 组件通信 (3)",
    "createdAt": 1707609600000,
    "content": "## Vue 组件通信\n\nVue 组件间有多种通信方式，适用于不同的场景。\n\n### Props 和 Events\n```vue\n<!-- 父组件 -->\n<ChildComponent :data=\"parentData\" @update=\"handleUpdate\" />\n\n<!-- 子组件 -->\n<template>\n  <div @click=\"$emit('update', newData)\">\n    {{ data }}\n  </div>\n</template>\n<script>\nexport default {\n  props: ['data'],\n  emits: ['update']\n}\n</script>\n```\n\n### provide/inject\n```javascript\n// 祖先组件\nprovide() {\n  return {\n    theme: this.theme\n  }\n}\n\n// 后代组件\ninject: ['theme']\n```\n\n### Vuex/Pinia\n- 全局状态管理\n- 跨组件共享数据\n\n### 事件总线（已废弃）\n- 使用全局事件总线\n- Vue 3 推荐使用 mitt 库\n\n### 最佳实践\n- 父子组件用 props/events\n- 跨层级用 provide/inject\n- 全局状态用状态管理",
    "id": 42,
    "hash": "33d21b1d2b2c83ee03565199076d14a2"
  },
  "43": {
    "title": "Babel 转译原理 (3)",
    "createdAt": 1707696000000,
    "content": "## Babel 转译原理\n\nBabel 是一个 JavaScript 编译器，将 ES6+ 代码转换为向后兼容的 JavaScript 版本。\n\n### 工作流程\n1. **解析（Parse）**: 将代码转换为 AST\n2. **转换（Transform）**: 对 AST 进行操作\n3. **生成（Generate）**: 将 AST 转换为代码\n\n### 核心概念\n- **AST（抽象语法树）**: 代码的树形表示\n- **Plugin**: 转换规则\n- **Preset**: 插件集合\n\n### 配置示例\n```json\n{\n  \"presets\": [\"@babel/preset-env\"],\n  \"plugins\": [\"@babel/plugin-proposal-class-properties\"]\n}\n```\n\n### 常用 Preset\n- `@babel/preset-env`: 根据目标环境转换\n- `@babel/preset-react`: React 语法转换\n- `@babel/preset-typescript`: TypeScript 转换\n\n### Polyfill\n- `@babel/polyfill`: 已废弃\n- `core-js`: 提供 polyfill\n- `regenerator-runtime`: async/await 支持",
    "id": 43,
    "hash": "9f220ab556d3608490cb9b53fedd0e67"
  },
  "44": {
    "title": "ESLint 代码检查 (3)",
    "createdAt": 1707782400000,
    "content": "## ESLint 代码检查\n\nESLint 是一个可插拔的 JavaScript 代码检查工具，用于发现和修复代码问题。\n\n### 配置文件\n```json\n{\n  \"extends\": [\"eslint:recommended\"],\n  \"rules\": {\n    \"no-console\": \"warn\",\n    \"no-unused-vars\": \"error\"\n  }\n}\n```\n\n### 常用规则\n- `no-console`: 禁止使用 console\n- `no-unused-vars`: 禁止未使用的变量\n- `eqeqeq`: 要求使用 === 和 !==\n- `semi`: 要求或禁止分号\n\n### 与 Prettier 集成\n```json\n{\n  \"extends\": [\n    \"eslint:recommended\",\n    \"plugin:prettier/recommended\"\n  ]\n}\n```\n\n### 优势\n- 统一代码风格\n- 提前发现错误\n- 提高代码质量\n- 团队协作规范",
    "id": 44,
    "hash": "25cd06d59e00f46d3c7657dabf7431db"
  },
  "45": {
    "title": "Git 工作流 (3)",
    "createdAt": 1707868800000,
    "content": "## Git 工作流\n\nGit 是分布式版本控制系统，用于跟踪代码变更。\n\n### 基本命令\n```bash\ngit add .          # 暂存更改\ngit commit -m \"msg\" # 提交更改\ngit push           # 推送到远程\ngit pull           # 拉取更新\ngit branch         # 查看分支\ngit merge          # 合并分支\n```\n\n### 工作流模型\n- **Git Flow**: 功能分支、发布分支\n- **GitHub Flow**: 简化的工作流\n- **GitLab Flow**: 带环境分支\n\n### 最佳实践\n- 频繁提交小改动\n- 写清晰的提交信息\n- 使用分支开发\n- 代码审查\n\n### 常用场景\n- 功能开发: feature 分支\n- 修复 bug: hotfix 分支\n- 发布版本: release 分支",
    "id": 45,
    "hash": "52a27ce13cb18bfc0a5bc944fe8af79e"
  },
  "46": {
    "title": "CSS Grid 布局 (4)",
    "createdAt": 1707955200000,
    "content": "## CSS Grid 布局\n\nCSS Grid 是二维布局系统，可以同时处理行和列。它是 Flexbox 的补充，适合复杂的网格布局。\n\n### 基本概念\n- **Grid 容器**: 使用 `display: grid` 创建网格容器\n- **Grid 项目**: 容器内的直接子元素\n- **网格线**: 网格的分割线\n- **网格轨道**: 两条网格线之间的空间\n\n### 容器属性\n```css\n.grid-container {\n  display: grid;\n  grid-template-columns: repeat(3, 1fr);\n  grid-template-rows: auto;\n  gap: 20px;\n}\n```\n\n### 项目属性\n- `grid-column`: 指定项目占据的列\n- `grid-row`: 指定项目占据的行\n- `grid-area`: 指定项目占据的区域\n\n### 适用场景\n- 复杂的二维布局\n- 响应式网格系统\n- 卡片网格布局\n- 页面整体布局",
    "id": 46,
    "hash": "9d769aa6987f53596410e0a9b3e4861e"
  },
  "47": {
    "title": "Promise 和异步编程 (4)",
    "createdAt": 1708041600000,
    "content": "## Promise 和异步编程\n\nPromise 是 JavaScript 中处理异步操作的对象，它代表一个异步操作的最终完成或失败。\n\n### 基本用法\n```javascript\nconst promise = new Promise((resolve, reject) => {\n  // 异步操作\n  if (success) {\n    resolve(value);\n  } else {\n    reject(error);\n  }\n});\n\npromise.then(value => {\n  // 成功处理\n}).catch(error => {\n  // 错误处理\n});\n```\n\n### Promise 方法\n- `Promise.all()`: 所有 Promise 都成功\n- `Promise.race()`: 第一个完成的 Promise\n- `Promise.allSettled()`: 等待所有 Promise 完成\n- `Promise.any()`: 第一个成功的 Promise\n\n### async/await\n```javascript\nasync function fetchData() {\n  try {\n    const data = await fetch(url);\n    return data.json();\n  } catch (error) {\n    console.error(error);\n  }\n}\n```\n\n### 优势\n- 避免回调地狱\n- 更好的错误处理\n- 链式调用\n- 代码更易读",
    "id": 47,
    "hash": "fd6c8eb45c4b9c162f55d6380e131f02"
  },
  "48": {
    "title": "JavaScript 原型链 (4)",
    "createdAt": 1708128000000,
    "content": "## JavaScript 原型链\n\n原型链是 JavaScript 实现继承的机制。每个对象都有一个指向其原型对象的内部链接。\n\n### 原型对象\n```javascript\nfunction Person(name) {\n  this.name = name;\n}\n\nPerson.prototype.sayHello = function() {\n  console.log(`Hello, I am ${this.name}`);\n};\n\nconst person = new Person(\"Alice\");\nperson.sayHello(); // 通过原型链访问\n```\n\n### 原型链查找\n1. 对象自身属性\n2. 对象的 `__proto__` 指向的原型\n3. 原型的原型，直到 `Object.prototype`\n4. `Object.prototype.__proto__` 为 `null`\n\n### 继承实现\n```javascript\nfunction Student(name, grade) {\n  Person.call(this, name);\n  this.grade = grade;\n}\n\nStudent.prototype = Object.create(Person.prototype);\nStudent.prototype.constructor = Student;\n```\n\n### ES6 Class\n```javascript\nclass Person {\n  constructor(name) {\n    this.name = name;\n  }\n  sayHello() {\n    console.log(`Hello, I am ${this.name}`);\n  }\n}\n```\n\n### 注意事项\n- 理解原型链有助于理解 JavaScript 继承\n- 避免修改内置对象的原型\n- 使用 `Object.create()` 创建对象",
    "id": 48,
    "hash": "ad49377f1181c89f05e363b7527e0650"
  },
  "49": {
    "title": "防抖和节流 (4)",
    "createdAt": 1708214400000,
    "content": "## 防抖和节流\n\n防抖（debounce）和节流（throttle）是限制函数执行频率的两种技术。\n\n### 防抖（Debounce）\n在事件被触发 n 秒后再执行回调，如果在这 n 秒内又被触发，则重新计时。\n\n```javascript\nfunction debounce(func, delay) {\n  let timeoutId;\n  return function(...args) {\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(() => func.apply(this, args), delay);\n  };\n}\n\n// 使用\nconst handleInput = debounce((e) => {\n  console.log(e.target.value);\n}, 300);\n```\n\n### 节流（Throttle）\n规定在一个单位时间内，只能触发一次函数。\n\n```javascript\nfunction throttle(func, delay) {\n  let lastTime = 0;\n  return function(...args) {\n    const now = Date.now();\n    if (now - lastTime >= delay) {\n      lastTime = now;\n      func.apply(this, args);\n    }\n  };\n}\n```\n\n### 使用场景\n- **防抖**: 搜索框输入、窗口 resize\n- **节流**: 滚动事件、鼠标移动\n\n### React Hooks 实现\n```javascript\nfunction useDebounce(value, delay) {\n  const [debouncedValue, setDebouncedValue] = useState(value);\n  useEffect(() => {\n    const handler = setTimeout(() => setDebouncedValue(value), delay);\n    return () => clearTimeout(handler);\n  }, [value, delay]);\n  return debouncedValue;\n}\n```",
    "id": 49,
    "hash": "fb49f4f18606e57a8c2cd6e2e7b8dac3"
  },
  "50": {
    "title": "CSS 变量（Custom Properties） (4)",
    "createdAt": 1708300800000,
    "content": "## CSS 变量（Custom Properties）\n\nCSS 变量允许在样式表中定义可重用的值，提高样式的可维护性。\n\n### 定义变量\n```css\n:root {\n  --primary-color: #3498db;\n  --secondary-color: #2ecc71;\n  --font-size-base: 16px;\n  --spacing-unit: 8px;\n}\n```\n\n### 使用变量\n```css\n.button {\n  background-color: var(--primary-color);\n  font-size: var(--font-size-base);\n  padding: calc(var(--spacing-unit) * 2);\n}\n```\n\n### JavaScript 操作\n```javascript\n// 获取变量值\nconst primaryColor = getComputedStyle(document.documentElement)\n  .getPropertyValue(\"--primary-color\");\n\n// 设置变量值\ndocument.documentElement.style.setProperty(\"--primary-color\", \"#ff0000\");\n```\n\n### 优势\n- 主题切换\n- 动态样式\n- 减少重复代码\n- 易于维护\n\n### 作用域\n- `:root`: 全局作用域\n- 元素选择器: 局部作用域\n- 继承性: 子元素可以继承父元素的变量",
    "id": 50,
    "hash": "c7a42f3a0db1827ead975d6e12f037da"
  },
  "51": {
    "title": "React 组件生命周期 (4)",
    "createdAt": 1708387200000,
    "content": "## React 组件生命周期\n\nReact 组件的生命周期分为三个阶段：挂载、更新和卸载。\n\n### 类组件生命周期\n```javascript\nclass MyComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    // 初始化状态\n  }\n  \n  componentDidMount() {\n    // 组件挂载后\n  }\n  \n  componentDidUpdate(prevProps, prevState) {\n    // 组件更新后\n  }\n  \n  componentWillUnmount() {\n    // 组件卸载前\n  }\n}\n```\n\n### 函数组件等效\n```javascript\nuseEffect(() => {\n  // componentDidMount + componentDidUpdate\n  return () => {\n    // componentWillUnmount\n  };\n}, [dependencies]);\n```\n\n### 生命周期阶段\n- **挂载**: constructor → render → componentDidMount\n- **更新**: render → componentDidUpdate\n- **卸载**: componentWillUnmount\n\n### 注意事项\n- 函数组件使用 Hooks 替代生命周期\n- 避免在 render 中执行副作用\n- 及时清理订阅和定时器",
    "id": 51,
    "hash": "296502c4a9cf0c26554393f71fff690a"
  },
  "52": {
    "title": "Vue 组件通信 (4)",
    "createdAt": 1708473600000,
    "content": "## Vue 组件通信\n\nVue 组件间有多种通信方式，适用于不同的场景。\n\n### Props 和 Events\n```vue\n<!-- 父组件 -->\n<ChildComponent :data=\"parentData\" @update=\"handleUpdate\" />\n\n<!-- 子组件 -->\n<template>\n  <div @click=\"$emit('update', newData)\">\n    {{ data }}\n  </div>\n</template>\n<script>\nexport default {\n  props: ['data'],\n  emits: ['update']\n}\n</script>\n```\n\n### provide/inject\n```javascript\n// 祖先组件\nprovide() {\n  return {\n    theme: this.theme\n  }\n}\n\n// 后代组件\ninject: ['theme']\n```\n\n### Vuex/Pinia\n- 全局状态管理\n- 跨组件共享数据\n\n### 事件总线（已废弃）\n- 使用全局事件总线\n- Vue 3 推荐使用 mitt 库\n\n### 最佳实践\n- 父子组件用 props/events\n- 跨层级用 provide/inject\n- 全局状态用状态管理",
    "id": 52,
    "hash": "b8799cfd46407892925d470b4ded1d19"
  },
  "53": {
    "title": "Babel 转译原理 (4)",
    "createdAt": 1708560000000,
    "content": "## Babel 转译原理\n\nBabel 是一个 JavaScript 编译器，将 ES6+ 代码转换为向后兼容的 JavaScript 版本。\n\n### 工作流程\n1. **解析（Parse）**: 将代码转换为 AST\n2. **转换（Transform）**: 对 AST 进行操作\n3. **生成（Generate）**: 将 AST 转换为代码\n\n### 核心概念\n- **AST（抽象语法树）**: 代码的树形表示\n- **Plugin**: 转换规则\n- **Preset**: 插件集合\n\n### 配置示例\n```json\n{\n  \"presets\": [\"@babel/preset-env\"],\n  \"plugins\": [\"@babel/plugin-proposal-class-properties\"]\n}\n```\n\n### 常用 Preset\n- `@babel/preset-env`: 根据目标环境转换\n- `@babel/preset-react`: React 语法转换\n- `@babel/preset-typescript`: TypeScript 转换\n\n### Polyfill\n- `@babel/polyfill`: 已废弃\n- `core-js`: 提供 polyfill\n- `regenerator-runtime`: async/await 支持",
    "id": 53,
    "hash": "8ce0646747ae99e0fe89a0dea4ad3194"
  },
  "54": {
    "title": "ESLint 代码检查 (4)",
    "createdAt": 1708646400000,
    "content": "## ESLint 代码检查\n\nESLint 是一个可插拔的 JavaScript 代码检查工具，用于发现和修复代码问题。\n\n### 配置文件\n```json\n{\n  \"extends\": [\"eslint:recommended\"],\n  \"rules\": {\n    \"no-console\": \"warn\",\n    \"no-unused-vars\": \"error\"\n  }\n}\n```\n\n### 常用规则\n- `no-console`: 禁止使用 console\n- `no-unused-vars`: 禁止未使用的变量\n- `eqeqeq`: 要求使用 === 和 !==\n- `semi`: 要求或禁止分号\n\n### 与 Prettier 集成\n```json\n{\n  \"extends\": [\n    \"eslint:recommended\",\n    \"plugin:prettier/recommended\"\n  ]\n}\n```\n\n### 优势\n- 统一代码风格\n- 提前发现错误\n- 提高代码质量\n- 团队协作规范",
    "id": 54,
    "hash": "6d99515dd1cd110a437c66e800351bac"
  },
  "55": {
    "title": "Git 工作流 (4)",
    "createdAt": 1708732800000,
    "content": "## Git 工作流\n\nGit 是分布式版本控制系统，用于跟踪代码变更。\n\n### 基本命令\n```bash\ngit add .          # 暂存更改\ngit commit -m \"msg\" # 提交更改\ngit push           # 推送到远程\ngit pull           # 拉取更新\ngit branch         # 查看分支\ngit merge          # 合并分支\n```\n\n### 工作流模型\n- **Git Flow**: 功能分支、发布分支\n- **GitHub Flow**: 简化的工作流\n- **GitLab Flow**: 带环境分支\n\n### 最佳实践\n- 频繁提交小改动\n- 写清晰的提交信息\n- 使用分支开发\n- 代码审查\n\n### 常用场景\n- 功能开发: feature 分支\n- 修复 bug: hotfix 分支\n- 发布版本: release 分支",
    "id": 55,
    "hash": "3b05ebef3f9035e56cb63813179ee15a"
  },
  "56": {
    "title": "CSS Grid 布局 (5)",
    "createdAt": 1708819200000,
    "content": "## CSS Grid 布局\n\nCSS Grid 是二维布局系统，可以同时处理行和列。它是 Flexbox 的补充，适合复杂的网格布局。\n\n### 基本概念\n- **Grid 容器**: 使用 `display: grid` 创建网格容器\n- **Grid 项目**: 容器内的直接子元素\n- **网格线**: 网格的分割线\n- **网格轨道**: 两条网格线之间的空间\n\n### 容器属性\n```css\n.grid-container {\n  display: grid;\n  grid-template-columns: repeat(3, 1fr);\n  grid-template-rows: auto;\n  gap: 20px;\n}\n```\n\n### 项目属性\n- `grid-column`: 指定项目占据的列\n- `grid-row`: 指定项目占据的行\n- `grid-area`: 指定项目占据的区域\n\n### 适用场景\n- 复杂的二维布局\n- 响应式网格系统\n- 卡片网格布局\n- 页面整体布局",
    "id": 56,
    "hash": "449c0254edd92b340cec34686654f3aa"
  },
  "57": {
    "title": "Promise 和异步编程 (5)",
    "createdAt": 1708905600000,
    "content": "## Promise 和异步编程\n\nPromise 是 JavaScript 中处理异步操作的对象，它代表一个异步操作的最终完成或失败。\n\n### 基本用法\n```javascript\nconst promise = new Promise((resolve, reject) => {\n  // 异步操作\n  if (success) {\n    resolve(value);\n  } else {\n    reject(error);\n  }\n});\n\npromise.then(value => {\n  // 成功处理\n}).catch(error => {\n  // 错误处理\n});\n```\n\n### Promise 方法\n- `Promise.all()`: 所有 Promise 都成功\n- `Promise.race()`: 第一个完成的 Promise\n- `Promise.allSettled()`: 等待所有 Promise 完成\n- `Promise.any()`: 第一个成功的 Promise\n\n### async/await\n```javascript\nasync function fetchData() {\n  try {\n    const data = await fetch(url);\n    return data.json();\n  } catch (error) {\n    console.error(error);\n  }\n}\n```\n\n### 优势\n- 避免回调地狱\n- 更好的错误处理\n- 链式调用\n- 代码更易读",
    "id": 57,
    "hash": "7d3c9e0fa2e799bab9727a4344bc8a4e"
  },
  "58": {
    "title": "JavaScript 原型链 (5)",
    "createdAt": 1708992000000,
    "content": "## JavaScript 原型链\n\n原型链是 JavaScript 实现继承的机制。每个对象都有一个指向其原型对象的内部链接。\n\n### 原型对象\n```javascript\nfunction Person(name) {\n  this.name = name;\n}\n\nPerson.prototype.sayHello = function() {\n  console.log(`Hello, I am ${this.name}`);\n};\n\nconst person = new Person(\"Alice\");\nperson.sayHello(); // 通过原型链访问\n```\n\n### 原型链查找\n1. 对象自身属性\n2. 对象的 `__proto__` 指向的原型\n3. 原型的原型，直到 `Object.prototype`\n4. `Object.prototype.__proto__` 为 `null`\n\n### 继承实现\n```javascript\nfunction Student(name, grade) {\n  Person.call(this, name);\n  this.grade = grade;\n}\n\nStudent.prototype = Object.create(Person.prototype);\nStudent.prototype.constructor = Student;\n```\n\n### ES6 Class\n```javascript\nclass Person {\n  constructor(name) {\n    this.name = name;\n  }\n  sayHello() {\n    console.log(`Hello, I am ${this.name}`);\n  }\n}\n```\n\n### 注意事项\n- 理解原型链有助于理解 JavaScript 继承\n- 避免修改内置对象的原型\n- 使用 `Object.create()` 创建对象",
    "id": 58,
    "hash": "42a95ab42351138ba070b6049eff8348"
  },
  "59": {
    "title": "防抖和节流 (5)",
    "createdAt": 1709078400000,
    "content": "## 防抖和节流\n\n防抖（debounce）和节流（throttle）是限制函数执行频率的两种技术。\n\n### 防抖（Debounce）\n在事件被触发 n 秒后再执行回调，如果在这 n 秒内又被触发，则重新计时。\n\n```javascript\nfunction debounce(func, delay) {\n  let timeoutId;\n  return function(...args) {\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(() => func.apply(this, args), delay);\n  };\n}\n\n// 使用\nconst handleInput = debounce((e) => {\n  console.log(e.target.value);\n}, 300);\n```\n\n### 节流（Throttle）\n规定在一个单位时间内，只能触发一次函数。\n\n```javascript\nfunction throttle(func, delay) {\n  let lastTime = 0;\n  return function(...args) {\n    const now = Date.now();\n    if (now - lastTime >= delay) {\n      lastTime = now;\n      func.apply(this, args);\n    }\n  };\n}\n```\n\n### 使用场景\n- **防抖**: 搜索框输入、窗口 resize\n- **节流**: 滚动事件、鼠标移动\n\n### React Hooks 实现\n```javascript\nfunction useDebounce(value, delay) {\n  const [debouncedValue, setDebouncedValue] = useState(value);\n  useEffect(() => {\n    const handler = setTimeout(() => setDebouncedValue(value), delay);\n    return () => clearTimeout(handler);\n  }, [value, delay]);\n  return debouncedValue;\n}\n```",
    "id": 59,
    "hash": "def8d241784fd0ce216e438141ecc783"
  },
  "60": {
    "title": "CSS 变量（Custom Properties） (5)",
    "createdAt": 1709164800000,
    "content": "## CSS 变量（Custom Properties）\n\nCSS 变量允许在样式表中定义可重用的值，提高样式的可维护性。\n\n### 定义变量\n```css\n:root {\n  --primary-color: #3498db;\n  --secondary-color: #2ecc71;\n  --font-size-base: 16px;\n  --spacing-unit: 8px;\n}\n```\n\n### 使用变量\n```css\n.button {\n  background-color: var(--primary-color);\n  font-size: var(--font-size-base);\n  padding: calc(var(--spacing-unit) * 2);\n}\n```\n\n### JavaScript 操作\n```javascript\n// 获取变量值\nconst primaryColor = getComputedStyle(document.documentElement)\n  .getPropertyValue(\"--primary-color\");\n\n// 设置变量值\ndocument.documentElement.style.setProperty(\"--primary-color\", \"#ff0000\");\n```\n\n### 优势\n- 主题切换\n- 动态样式\n- 减少重复代码\n- 易于维护\n\n### 作用域\n- `:root`: 全局作用域\n- 元素选择器: 局部作用域\n- 继承性: 子元素可以继承父元素的变量",
    "id": 60,
    "hash": "5f218d480a29c9ccf9daf08443829266"
  },
  "61": {
    "title": "React 组件生命周期 (5)",
    "createdAt": 1709251200000,
    "content": "## React 组件生命周期\n\nReact 组件的生命周期分为三个阶段：挂载、更新和卸载。\n\n### 类组件生命周期\n```javascript\nclass MyComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    // 初始化状态\n  }\n  \n  componentDidMount() {\n    // 组件挂载后\n  }\n  \n  componentDidUpdate(prevProps, prevState) {\n    // 组件更新后\n  }\n  \n  componentWillUnmount() {\n    // 组件卸载前\n  }\n}\n```\n\n### 函数组件等效\n```javascript\nuseEffect(() => {\n  // componentDidMount + componentDidUpdate\n  return () => {\n    // componentWillUnmount\n  };\n}, [dependencies]);\n```\n\n### 生命周期阶段\n- **挂载**: constructor → render → componentDidMount\n- **更新**: render → componentDidUpdate\n- **卸载**: componentWillUnmount\n\n### 注意事项\n- 函数组件使用 Hooks 替代生命周期\n- 避免在 render 中执行副作用\n- 及时清理订阅和定时器",
    "id": 61,
    "hash": "18820693a9f352deafffc9d91402cbf6"
  },
  "62": {
    "title": "Vue 组件通信 (5)",
    "createdAt": 1709337600000,
    "content": "## Vue 组件通信\n\nVue 组件间有多种通信方式，适用于不同的场景。\n\n### Props 和 Events\n```vue\n<!-- 父组件 -->\n<ChildComponent :data=\"parentData\" @update=\"handleUpdate\" />\n\n<!-- 子组件 -->\n<template>\n  <div @click=\"$emit('update', newData)\">\n    {{ data }}\n  </div>\n</template>\n<script>\nexport default {\n  props: ['data'],\n  emits: ['update']\n}\n</script>\n```\n\n### provide/inject\n```javascript\n// 祖先组件\nprovide() {\n  return {\n    theme: this.theme\n  }\n}\n\n// 后代组件\ninject: ['theme']\n```\n\n### Vuex/Pinia\n- 全局状态管理\n- 跨组件共享数据\n\n### 事件总线（已废弃）\n- 使用全局事件总线\n- Vue 3 推荐使用 mitt 库\n\n### 最佳实践\n- 父子组件用 props/events\n- 跨层级用 provide/inject\n- 全局状态用状态管理",
    "id": 62,
    "hash": "5d1591bf02d804e02bde2a9ff1c28b05"
  },
  "63": {
    "title": "Babel 转译原理 (5)",
    "createdAt": 1709424000000,
    "content": "## Babel 转译原理\n\nBabel 是一个 JavaScript 编译器，将 ES6+ 代码转换为向后兼容的 JavaScript 版本。\n\n### 工作流程\n1. **解析（Parse）**: 将代码转换为 AST\n2. **转换（Transform）**: 对 AST 进行操作\n3. **生成（Generate）**: 将 AST 转换为代码\n\n### 核心概念\n- **AST（抽象语法树）**: 代码的树形表示\n- **Plugin**: 转换规则\n- **Preset**: 插件集合\n\n### 配置示例\n```json\n{\n  \"presets\": [\"@babel/preset-env\"],\n  \"plugins\": [\"@babel/plugin-proposal-class-properties\"]\n}\n```\n\n### 常用 Preset\n- `@babel/preset-env`: 根据目标环境转换\n- `@babel/preset-react`: React 语法转换\n- `@babel/preset-typescript`: TypeScript 转换\n\n### Polyfill\n- `@babel/polyfill`: 已废弃\n- `core-js`: 提供 polyfill\n- `regenerator-runtime`: async/await 支持",
    "id": 63,
    "hash": "a85dd455745002e9936224ddc8994f2c"
  },
  "64": {
    "title": "ESLint 代码检查 (5)",
    "createdAt": 1709510400000,
    "content": "## ESLint 代码检查\n\nESLint 是一个可插拔的 JavaScript 代码检查工具，用于发现和修复代码问题。\n\n### 配置文件\n```json\n{\n  \"extends\": [\"eslint:recommended\"],\n  \"rules\": {\n    \"no-console\": \"warn\",\n    \"no-unused-vars\": \"error\"\n  }\n}\n```\n\n### 常用规则\n- `no-console`: 禁止使用 console\n- `no-unused-vars`: 禁止未使用的变量\n- `eqeqeq`: 要求使用 === 和 !==\n- `semi`: 要求或禁止分号\n\n### 与 Prettier 集成\n```json\n{\n  \"extends\": [\n    \"eslint:recommended\",\n    \"plugin:prettier/recommended\"\n  ]\n}\n```\n\n### 优势\n- 统一代码风格\n- 提前发现错误\n- 提高代码质量\n- 团队协作规范",
    "id": 64,
    "hash": "1e635d9879853dbca87dd373c070c941"
  },
  "65": {
    "title": "Git 工作流 (5)",
    "createdAt": 1709596800000,
    "content": "## Git 工作流\n\nGit 是分布式版本控制系统，用于跟踪代码变更。\n\n### 基本命令\n```bash\ngit add .          # 暂存更改\ngit commit -m \"msg\" # 提交更改\ngit push           # 推送到远程\ngit pull           # 拉取更新\ngit branch         # 查看分支\ngit merge          # 合并分支\n```\n\n### 工作流模型\n- **Git Flow**: 功能分支、发布分支\n- **GitHub Flow**: 简化的工作流\n- **GitLab Flow**: 带环境分支\n\n### 最佳实践\n- 频繁提交小改动\n- 写清晰的提交信息\n- 使用分支开发\n- 代码审查\n\n### 常用场景\n- 功能开发: feature 分支\n- 修复 bug: hotfix 分支\n- 发布版本: release 分支",
    "id": 65,
    "hash": "c8bcb49fa6113c1a7e1333544b546c41"
  },
  "66": {
    "title": "CSS Grid 布局 (6)",
    "createdAt": 1709683200000,
    "content": "## CSS Grid 布局\n\nCSS Grid 是二维布局系统，可以同时处理行和列。它是 Flexbox 的补充，适合复杂的网格布局。\n\n### 基本概念\n- **Grid 容器**: 使用 `display: grid` 创建网格容器\n- **Grid 项目**: 容器内的直接子元素\n- **网格线**: 网格的分割线\n- **网格轨道**: 两条网格线之间的空间\n\n### 容器属性\n```css\n.grid-container {\n  display: grid;\n  grid-template-columns: repeat(3, 1fr);\n  grid-template-rows: auto;\n  gap: 20px;\n}\n```\n\n### 项目属性\n- `grid-column`: 指定项目占据的列\n- `grid-row`: 指定项目占据的行\n- `grid-area`: 指定项目占据的区域\n\n### 适用场景\n- 复杂的二维布局\n- 响应式网格系统\n- 卡片网格布局\n- 页面整体布局",
    "id": 66,
    "hash": "af41289a620e15ab16b338e357007088"
  },
  "67": {
    "title": "Promise 和异步编程 (6)",
    "createdAt": 1709769600000,
    "content": "## Promise 和异步编程\n\nPromise 是 JavaScript 中处理异步操作的对象，它代表一个异步操作的最终完成或失败。\n\n### 基本用法\n```javascript\nconst promise = new Promise((resolve, reject) => {\n  // 异步操作\n  if (success) {\n    resolve(value);\n  } else {\n    reject(error);\n  }\n});\n\npromise.then(value => {\n  // 成功处理\n}).catch(error => {\n  // 错误处理\n});\n```\n\n### Promise 方法\n- `Promise.all()`: 所有 Promise 都成功\n- `Promise.race()`: 第一个完成的 Promise\n- `Promise.allSettled()`: 等待所有 Promise 完成\n- `Promise.any()`: 第一个成功的 Promise\n\n### async/await\n```javascript\nasync function fetchData() {\n  try {\n    const data = await fetch(url);\n    return data.json();\n  } catch (error) {\n    console.error(error);\n  }\n}\n```\n\n### 优势\n- 避免回调地狱\n- 更好的错误处理\n- 链式调用\n- 代码更易读",
    "id": 67,
    "hash": "61ffce0c37a03718421ff612124f754b"
  },
  "68": {
    "title": "JavaScript 原型链 (6)",
    "createdAt": 1709856000000,
    "content": "## JavaScript 原型链\n\n原型链是 JavaScript 实现继承的机制。每个对象都有一个指向其原型对象的内部链接。\n\n### 原型对象\n```javascript\nfunction Person(name) {\n  this.name = name;\n}\n\nPerson.prototype.sayHello = function() {\n  console.log(`Hello, I am ${this.name}`);\n};\n\nconst person = new Person(\"Alice\");\nperson.sayHello(); // 通过原型链访问\n```\n\n### 原型链查找\n1. 对象自身属性\n2. 对象的 `__proto__` 指向的原型\n3. 原型的原型，直到 `Object.prototype`\n4. `Object.prototype.__proto__` 为 `null`\n\n### 继承实现\n```javascript\nfunction Student(name, grade) {\n  Person.call(this, name);\n  this.grade = grade;\n}\n\nStudent.prototype = Object.create(Person.prototype);\nStudent.prototype.constructor = Student;\n```\n\n### ES6 Class\n```javascript\nclass Person {\n  constructor(name) {\n    this.name = name;\n  }\n  sayHello() {\n    console.log(`Hello, I am ${this.name}`);\n  }\n}\n```\n\n### 注意事项\n- 理解原型链有助于理解 JavaScript 继承\n- 避免修改内置对象的原型\n- 使用 `Object.create()` 创建对象",
    "id": 68,
    "hash": "a7e1d5760b7db4f210bcc725069a0499"
  },
  "69": {
    "title": "防抖和节流 (6)",
    "createdAt": 1709942400000,
    "content": "## 防抖和节流\n\n防抖（debounce）和节流（throttle）是限制函数执行频率的两种技术。\n\n### 防抖（Debounce）\n在事件被触发 n 秒后再执行回调，如果在这 n 秒内又被触发，则重新计时。\n\n```javascript\nfunction debounce(func, delay) {\n  let timeoutId;\n  return function(...args) {\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(() => func.apply(this, args), delay);\n  };\n}\n\n// 使用\nconst handleInput = debounce((e) => {\n  console.log(e.target.value);\n}, 300);\n```\n\n### 节流（Throttle）\n规定在一个单位时间内，只能触发一次函数。\n\n```javascript\nfunction throttle(func, delay) {\n  let lastTime = 0;\n  return function(...args) {\n    const now = Date.now();\n    if (now - lastTime >= delay) {\n      lastTime = now;\n      func.apply(this, args);\n    }\n  };\n}\n```\n\n### 使用场景\n- **防抖**: 搜索框输入、窗口 resize\n- **节流**: 滚动事件、鼠标移动\n\n### React Hooks 实现\n```javascript\nfunction useDebounce(value, delay) {\n  const [debouncedValue, setDebouncedValue] = useState(value);\n  useEffect(() => {\n    const handler = setTimeout(() => setDebouncedValue(value), delay);\n    return () => clearTimeout(handler);\n  }, [value, delay]);\n  return debouncedValue;\n}\n```",
    "id": 69,
    "hash": "d9b19ddfe4cf6611fb714f6c05ef1e44"
  },
  "70": {
    "title": "CSS 变量（Custom Properties） (6)",
    "createdAt": 1710028800000,
    "content": "## CSS 变量（Custom Properties）\n\nCSS 变量允许在样式表中定义可重用的值，提高样式的可维护性。\n\n### 定义变量\n```css\n:root {\n  --primary-color: #3498db;\n  --secondary-color: #2ecc71;\n  --font-size-base: 16px;\n  --spacing-unit: 8px;\n}\n```\n\n### 使用变量\n```css\n.button {\n  background-color: var(--primary-color);\n  font-size: var(--font-size-base);\n  padding: calc(var(--spacing-unit) * 2);\n}\n```\n\n### JavaScript 操作\n```javascript\n// 获取变量值\nconst primaryColor = getComputedStyle(document.documentElement)\n  .getPropertyValue(\"--primary-color\");\n\n// 设置变量值\ndocument.documentElement.style.setProperty(\"--primary-color\", \"#ff0000\");\n```\n\n### 优势\n- 主题切换\n- 动态样式\n- 减少重复代码\n- 易于维护\n\n### 作用域\n- `:root`: 全局作用域\n- 元素选择器: 局部作用域\n- 继承性: 子元素可以继承父元素的变量",
    "id": 70,
    "hash": "62a5e6da36ecc77b40c5829b4e85fda1"
  },
  "71": {
    "title": "React 组件生命周期 (6)",
    "createdAt": 1710115200000,
    "content": "## React 组件生命周期\n\nReact 组件的生命周期分为三个阶段：挂载、更新和卸载。\n\n### 类组件生命周期\n```javascript\nclass MyComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    // 初始化状态\n  }\n  \n  componentDidMount() {\n    // 组件挂载后\n  }\n  \n  componentDidUpdate(prevProps, prevState) {\n    // 组件更新后\n  }\n  \n  componentWillUnmount() {\n    // 组件卸载前\n  }\n}\n```\n\n### 函数组件等效\n```javascript\nuseEffect(() => {\n  // componentDidMount + componentDidUpdate\n  return () => {\n    // componentWillUnmount\n  };\n}, [dependencies]);\n```\n\n### 生命周期阶段\n- **挂载**: constructor → render → componentDidMount\n- **更新**: render → componentDidUpdate\n- **卸载**: componentWillUnmount\n\n### 注意事项\n- 函数组件使用 Hooks 替代生命周期\n- 避免在 render 中执行副作用\n- 及时清理订阅和定时器",
    "id": 71,
    "hash": "27b1c4eeb5af14948419bf97a7f6e124"
  },
  "72": {
    "title": "Vue 组件通信 (6)",
    "createdAt": 1710201600000,
    "content": "## Vue 组件通信\n\nVue 组件间有多种通信方式，适用于不同的场景。\n\n### Props 和 Events\n```vue\n<!-- 父组件 -->\n<ChildComponent :data=\"parentData\" @update=\"handleUpdate\" />\n\n<!-- 子组件 -->\n<template>\n  <div @click=\"$emit('update', newData)\">\n    {{ data }}\n  </div>\n</template>\n<script>\nexport default {\n  props: ['data'],\n  emits: ['update']\n}\n</script>\n```\n\n### provide/inject\n```javascript\n// 祖先组件\nprovide() {\n  return {\n    theme: this.theme\n  }\n}\n\n// 后代组件\ninject: ['theme']\n```\n\n### Vuex/Pinia\n- 全局状态管理\n- 跨组件共享数据\n\n### 事件总线（已废弃）\n- 使用全局事件总线\n- Vue 3 推荐使用 mitt 库\n\n### 最佳实践\n- 父子组件用 props/events\n- 跨层级用 provide/inject\n- 全局状态用状态管理",
    "id": 72,
    "hash": "fec09309963b04577232326e50c191eb"
  },
  "73": {
    "title": "Babel 转译原理 (6)",
    "createdAt": 1710288000000,
    "content": "## Babel 转译原理\n\nBabel 是一个 JavaScript 编译器，将 ES6+ 代码转换为向后兼容的 JavaScript 版本。\n\n### 工作流程\n1. **解析（Parse）**: 将代码转换为 AST\n2. **转换（Transform）**: 对 AST 进行操作\n3. **生成（Generate）**: 将 AST 转换为代码\n\n### 核心概念\n- **AST（抽象语法树）**: 代码的树形表示\n- **Plugin**: 转换规则\n- **Preset**: 插件集合\n\n### 配置示例\n```json\n{\n  \"presets\": [\"@babel/preset-env\"],\n  \"plugins\": [\"@babel/plugin-proposal-class-properties\"]\n}\n```\n\n### 常用 Preset\n- `@babel/preset-env`: 根据目标环境转换\n- `@babel/preset-react`: React 语法转换\n- `@babel/preset-typescript`: TypeScript 转换\n\n### Polyfill\n- `@babel/polyfill`: 已废弃\n- `core-js`: 提供 polyfill\n- `regenerator-runtime`: async/await 支持",
    "id": 73,
    "hash": "51d7fe47e352dddf2c7d1f33833de277"
  },
  "74": {
    "title": "ESLint 代码检查 (6)",
    "createdAt": 1710374400000,
    "content": "## ESLint 代码检查\n\nESLint 是一个可插拔的 JavaScript 代码检查工具，用于发现和修复代码问题。\n\n### 配置文件\n```json\n{\n  \"extends\": [\"eslint:recommended\"],\n  \"rules\": {\n    \"no-console\": \"warn\",\n    \"no-unused-vars\": \"error\"\n  }\n}\n```\n\n### 常用规则\n- `no-console`: 禁止使用 console\n- `no-unused-vars`: 禁止未使用的变量\n- `eqeqeq`: 要求使用 === 和 !==\n- `semi`: 要求或禁止分号\n\n### 与 Prettier 集成\n```json\n{\n  \"extends\": [\n    \"eslint:recommended\",\n    \"plugin:prettier/recommended\"\n  ]\n}\n```\n\n### 优势\n- 统一代码风格\n- 提前发现错误\n- 提高代码质量\n- 团队协作规范",
    "id": 74,
    "hash": "0c194e3065d7f300c42f8115bfd33ae4"
  },
  "75": {
    "title": "Git 工作流 (6)",
    "createdAt": 1710460800000,
    "content": "## Git 工作流\n\nGit 是分布式版本控制系统，用于跟踪代码变更。\n\n### 基本命令\n```bash\ngit add .          # 暂存更改\ngit commit -m \"msg\" # 提交更改\ngit push           # 推送到远程\ngit pull           # 拉取更新\ngit branch         # 查看分支\ngit merge          # 合并分支\n```\n\n### 工作流模型\n- **Git Flow**: 功能分支、发布分支\n- **GitHub Flow**: 简化的工作流\n- **GitLab Flow**: 带环境分支\n\n### 最佳实践\n- 频繁提交小改动\n- 写清晰的提交信息\n- 使用分支开发\n- 代码审查\n\n### 常用场景\n- 功能开发: feature 分支\n- 修复 bug: hotfix 分支\n- 发布版本: release 分支",
    "id": 75,
    "hash": "ef4fe879857a1a8f265c06ba68c1e87f"
  },
  "76": {
    "title": "CSS Grid 布局 (7)",
    "createdAt": 1710547200000,
    "content": "## CSS Grid 布局\n\nCSS Grid 是二维布局系统，可以同时处理行和列。它是 Flexbox 的补充，适合复杂的网格布局。\n\n### 基本概念\n- **Grid 容器**: 使用 `display: grid` 创建网格容器\n- **Grid 项目**: 容器内的直接子元素\n- **网格线**: 网格的分割线\n- **网格轨道**: 两条网格线之间的空间\n\n### 容器属性\n```css\n.grid-container {\n  display: grid;\n  grid-template-columns: repeat(3, 1fr);\n  grid-template-rows: auto;\n  gap: 20px;\n}\n```\n\n### 项目属性\n- `grid-column`: 指定项目占据的列\n- `grid-row`: 指定项目占据的行\n- `grid-area`: 指定项目占据的区域\n\n### 适用场景\n- 复杂的二维布局\n- 响应式网格系统\n- 卡片网格布局\n- 页面整体布局",
    "id": 76,
    "hash": "97b278430e960ade4a5ade9616d6b796"
  },
  "77": {
    "title": "Promise 和异步编程 (7)",
    "createdAt": 1710633600000,
    "content": "## Promise 和异步编程\n\nPromise 是 JavaScript 中处理异步操作的对象，它代表一个异步操作的最终完成或失败。\n\n### 基本用法\n```javascript\nconst promise = new Promise((resolve, reject) => {\n  // 异步操作\n  if (success) {\n    resolve(value);\n  } else {\n    reject(error);\n  }\n});\n\npromise.then(value => {\n  // 成功处理\n}).catch(error => {\n  // 错误处理\n});\n```\n\n### Promise 方法\n- `Promise.all()`: 所有 Promise 都成功\n- `Promise.race()`: 第一个完成的 Promise\n- `Promise.allSettled()`: 等待所有 Promise 完成\n- `Promise.any()`: 第一个成功的 Promise\n\n### async/await\n```javascript\nasync function fetchData() {\n  try {\n    const data = await fetch(url);\n    return data.json();\n  } catch (error) {\n    console.error(error);\n  }\n}\n```\n\n### 优势\n- 避免回调地狱\n- 更好的错误处理\n- 链式调用\n- 代码更易读",
    "id": 77,
    "hash": "b9080f29e6d307c505599b638863d23f"
  },
  "78": {
    "title": "JavaScript 原型链 (7)",
    "createdAt": 1710720000000,
    "content": "## JavaScript 原型链\n\n原型链是 JavaScript 实现继承的机制。每个对象都有一个指向其原型对象的内部链接。\n\n### 原型对象\n```javascript\nfunction Person(name) {\n  this.name = name;\n}\n\nPerson.prototype.sayHello = function() {\n  console.log(`Hello, I am ${this.name}`);\n};\n\nconst person = new Person(\"Alice\");\nperson.sayHello(); // 通过原型链访问\n```\n\n### 原型链查找\n1. 对象自身属性\n2. 对象的 `__proto__` 指向的原型\n3. 原型的原型，直到 `Object.prototype`\n4. `Object.prototype.__proto__` 为 `null`\n\n### 继承实现\n```javascript\nfunction Student(name, grade) {\n  Person.call(this, name);\n  this.grade = grade;\n}\n\nStudent.prototype = Object.create(Person.prototype);\nStudent.prototype.constructor = Student;\n```\n\n### ES6 Class\n```javascript\nclass Person {\n  constructor(name) {\n    this.name = name;\n  }\n  sayHello() {\n    console.log(`Hello, I am ${this.name}`);\n  }\n}\n```\n\n### 注意事项\n- 理解原型链有助于理解 JavaScript 继承\n- 避免修改内置对象的原型\n- 使用 `Object.create()` 创建对象",
    "id": 78,
    "hash": "56623a027b16bef0f4d7fb13e88a72e6"
  },
  "79": {
    "title": "防抖和节流 (7)",
    "createdAt": 1710806400000,
    "content": "## 防抖和节流\n\n防抖（debounce）和节流（throttle）是限制函数执行频率的两种技术。\n\n### 防抖（Debounce）\n在事件被触发 n 秒后再执行回调，如果在这 n 秒内又被触发，则重新计时。\n\n```javascript\nfunction debounce(func, delay) {\n  let timeoutId;\n  return function(...args) {\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(() => func.apply(this, args), delay);\n  };\n}\n\n// 使用\nconst handleInput = debounce((e) => {\n  console.log(e.target.value);\n}, 300);\n```\n\n### 节流（Throttle）\n规定在一个单位时间内，只能触发一次函数。\n\n```javascript\nfunction throttle(func, delay) {\n  let lastTime = 0;\n  return function(...args) {\n    const now = Date.now();\n    if (now - lastTime >= delay) {\n      lastTime = now;\n      func.apply(this, args);\n    }\n  };\n}\n```\n\n### 使用场景\n- **防抖**: 搜索框输入、窗口 resize\n- **节流**: 滚动事件、鼠标移动\n\n### React Hooks 实现\n```javascript\nfunction useDebounce(value, delay) {\n  const [debouncedValue, setDebouncedValue] = useState(value);\n  useEffect(() => {\n    const handler = setTimeout(() => setDebouncedValue(value), delay);\n    return () => clearTimeout(handler);\n  }, [value, delay]);\n  return debouncedValue;\n}\n```",
    "id": 79,
    "hash": "01308d6747aaf0cec2ac0e55ced4bdc0"
  },
  "80": {
    "title": "CSS 变量（Custom Properties） (7)",
    "createdAt": 1710892800000,
    "content": "## CSS 变量（Custom Properties）\n\nCSS 变量允许在样式表中定义可重用的值，提高样式的可维护性。\n\n### 定义变量\n```css\n:root {\n  --primary-color: #3498db;\n  --secondary-color: #2ecc71;\n  --font-size-base: 16px;\n  --spacing-unit: 8px;\n}\n```\n\n### 使用变量\n```css\n.button {\n  background-color: var(--primary-color);\n  font-size: var(--font-size-base);\n  padding: calc(var(--spacing-unit) * 2);\n}\n```\n\n### JavaScript 操作\n```javascript\n// 获取变量值\nconst primaryColor = getComputedStyle(document.documentElement)\n  .getPropertyValue(\"--primary-color\");\n\n// 设置变量值\ndocument.documentElement.style.setProperty(\"--primary-color\", \"#ff0000\");\n```\n\n### 优势\n- 主题切换\n- 动态样式\n- 减少重复代码\n- 易于维护\n\n### 作用域\n- `:root`: 全局作用域\n- 元素选择器: 局部作用域\n- 继承性: 子元素可以继承父元素的变量",
    "id": 80,
    "hash": "bdf179f1a2f11b156dac383ecc305d59"
  },
  "81": {
    "title": "React 组件生命周期 (7)",
    "createdAt": 1710979200000,
    "content": "## React 组件生命周期\n\nReact 组件的生命周期分为三个阶段：挂载、更新和卸载。\n\n### 类组件生命周期\n```javascript\nclass MyComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    // 初始化状态\n  }\n  \n  componentDidMount() {\n    // 组件挂载后\n  }\n  \n  componentDidUpdate(prevProps, prevState) {\n    // 组件更新后\n  }\n  \n  componentWillUnmount() {\n    // 组件卸载前\n  }\n}\n```\n\n### 函数组件等效\n```javascript\nuseEffect(() => {\n  // componentDidMount + componentDidUpdate\n  return () => {\n    // componentWillUnmount\n  };\n}, [dependencies]);\n```\n\n### 生命周期阶段\n- **挂载**: constructor → render → componentDidMount\n- **更新**: render → componentDidUpdate\n- **卸载**: componentWillUnmount\n\n### 注意事项\n- 函数组件使用 Hooks 替代生命周期\n- 避免在 render 中执行副作用\n- 及时清理订阅和定时器",
    "id": 81,
    "hash": "51f8dd10738fdb336534d0ab3e43c071"
  },
  "82": {
    "title": "Vue 组件通信 (7)",
    "createdAt": 1711065600000,
    "content": "## Vue 组件通信\n\nVue 组件间有多种通信方式，适用于不同的场景。\n\n### Props 和 Events\n```vue\n<!-- 父组件 -->\n<ChildComponent :data=\"parentData\" @update=\"handleUpdate\" />\n\n<!-- 子组件 -->\n<template>\n  <div @click=\"$emit('update', newData)\">\n    {{ data }}\n  </div>\n</template>\n<script>\nexport default {\n  props: ['data'],\n  emits: ['update']\n}\n</script>\n```\n\n### provide/inject\n```javascript\n// 祖先组件\nprovide() {\n  return {\n    theme: this.theme\n  }\n}\n\n// 后代组件\ninject: ['theme']\n```\n\n### Vuex/Pinia\n- 全局状态管理\n- 跨组件共享数据\n\n### 事件总线（已废弃）\n- 使用全局事件总线\n- Vue 3 推荐使用 mitt 库\n\n### 最佳实践\n- 父子组件用 props/events\n- 跨层级用 provide/inject\n- 全局状态用状态管理",
    "id": 82,
    "hash": "3c67368f5ab12c91d19770b8abfe2697"
  },
  "83": {
    "title": "Babel 转译原理 (7)",
    "createdAt": 1711152000000,
    "content": "## Babel 转译原理\n\nBabel 是一个 JavaScript 编译器，将 ES6+ 代码转换为向后兼容的 JavaScript 版本。\n\n### 工作流程\n1. **解析（Parse）**: 将代码转换为 AST\n2. **转换（Transform）**: 对 AST 进行操作\n3. **生成（Generate）**: 将 AST 转换为代码\n\n### 核心概念\n- **AST（抽象语法树）**: 代码的树形表示\n- **Plugin**: 转换规则\n- **Preset**: 插件集合\n\n### 配置示例\n```json\n{\n  \"presets\": [\"@babel/preset-env\"],\n  \"plugins\": [\"@babel/plugin-proposal-class-properties\"]\n}\n```\n\n### 常用 Preset\n- `@babel/preset-env`: 根据目标环境转换\n- `@babel/preset-react`: React 语法转换\n- `@babel/preset-typescript`: TypeScript 转换\n\n### Polyfill\n- `@babel/polyfill`: 已废弃\n- `core-js`: 提供 polyfill\n- `regenerator-runtime`: async/await 支持",
    "id": 83,
    "hash": "fe84ea0e7ef4dc4515eda21745c9d43a"
  },
  "84": {
    "title": "ESLint 代码检查 (7)",
    "createdAt": 1711238400000,
    "content": "## ESLint 代码检查\n\nESLint 是一个可插拔的 JavaScript 代码检查工具，用于发现和修复代码问题。\n\n### 配置文件\n```json\n{\n  \"extends\": [\"eslint:recommended\"],\n  \"rules\": {\n    \"no-console\": \"warn\",\n    \"no-unused-vars\": \"error\"\n  }\n}\n```\n\n### 常用规则\n- `no-console`: 禁止使用 console\n- `no-unused-vars`: 禁止未使用的变量\n- `eqeqeq`: 要求使用 === 和 !==\n- `semi`: 要求或禁止分号\n\n### 与 Prettier 集成\n```json\n{\n  \"extends\": [\n    \"eslint:recommended\",\n    \"plugin:prettier/recommended\"\n  ]\n}\n```\n\n### 优势\n- 统一代码风格\n- 提前发现错误\n- 提高代码质量\n- 团队协作规范",
    "id": 84,
    "hash": "f252d4cdd238709c104ebad4854bf750"
  },
  "85": {
    "title": "Git 工作流 (7)",
    "createdAt": 1711324800000,
    "content": "## Git 工作流\n\nGit 是分布式版本控制系统，用于跟踪代码变更。\n\n### 基本命令\n```bash\ngit add .          # 暂存更改\ngit commit -m \"msg\" # 提交更改\ngit push           # 推送到远程\ngit pull           # 拉取更新\ngit branch         # 查看分支\ngit merge          # 合并分支\n```\n\n### 工作流模型\n- **Git Flow**: 功能分支、发布分支\n- **GitHub Flow**: 简化的工作流\n- **GitLab Flow**: 带环境分支\n\n### 最佳实践\n- 频繁提交小改动\n- 写清晰的提交信息\n- 使用分支开发\n- 代码审查\n\n### 常用场景\n- 功能开发: feature 分支\n- 修复 bug: hotfix 分支\n- 发布版本: release 分支",
    "id": 85,
    "hash": "878a7dda0f2a1d3a89bb01dbb738f9a6"
  },
  "86": {
    "title": "CSS Grid 布局 (8)",
    "createdAt": 1711411200000,
    "content": "## CSS Grid 布局\n\nCSS Grid 是二维布局系统，可以同时处理行和列。它是 Flexbox 的补充，适合复杂的网格布局。\n\n### 基本概念\n- **Grid 容器**: 使用 `display: grid` 创建网格容器\n- **Grid 项目**: 容器内的直接子元素\n- **网格线**: 网格的分割线\n- **网格轨道**: 两条网格线之间的空间\n\n### 容器属性\n```css\n.grid-container {\n  display: grid;\n  grid-template-columns: repeat(3, 1fr);\n  grid-template-rows: auto;\n  gap: 20px;\n}\n```\n\n### 项目属性\n- `grid-column`: 指定项目占据的列\n- `grid-row`: 指定项目占据的行\n- `grid-area`: 指定项目占据的区域\n\n### 适用场景\n- 复杂的二维布局\n- 响应式网格系统\n- 卡片网格布局\n- 页面整体布局",
    "id": 86,
    "hash": "4338c8d6f2e0d883d7bd91909d72540a"
  },
  "87": {
    "title": "Promise 和异步编程 (8)",
    "createdAt": 1711497600000,
    "content": "## Promise 和异步编程\n\nPromise 是 JavaScript 中处理异步操作的对象，它代表一个异步操作的最终完成或失败。\n\n### 基本用法\n```javascript\nconst promise = new Promise((resolve, reject) => {\n  // 异步操作\n  if (success) {\n    resolve(value);\n  } else {\n    reject(error);\n  }\n});\n\npromise.then(value => {\n  // 成功处理\n}).catch(error => {\n  // 错误处理\n});\n```\n\n### Promise 方法\n- `Promise.all()`: 所有 Promise 都成功\n- `Promise.race()`: 第一个完成的 Promise\n- `Promise.allSettled()`: 等待所有 Promise 完成\n- `Promise.any()`: 第一个成功的 Promise\n\n### async/await\n```javascript\nasync function fetchData() {\n  try {\n    const data = await fetch(url);\n    return data.json();\n  } catch (error) {\n    console.error(error);\n  }\n}\n```\n\n### 优势\n- 避免回调地狱\n- 更好的错误处理\n- 链式调用\n- 代码更易读",
    "id": 87,
    "hash": "d4aa2b3d19db29ba820c8ad36e8a2533"
  },
  "88": {
    "title": "JavaScript 原型链 (8)",
    "createdAt": 1711584000000,
    "content": "## JavaScript 原型链\n\n原型链是 JavaScript 实现继承的机制。每个对象都有一个指向其原型对象的内部链接。\n\n### 原型对象\n```javascript\nfunction Person(name) {\n  this.name = name;\n}\n\nPerson.prototype.sayHello = function() {\n  console.log(`Hello, I am ${this.name}`);\n};\n\nconst person = new Person(\"Alice\");\nperson.sayHello(); // 通过原型链访问\n```\n\n### 原型链查找\n1. 对象自身属性\n2. 对象的 `__proto__` 指向的原型\n3. 原型的原型，直到 `Object.prototype`\n4. `Object.prototype.__proto__` 为 `null`\n\n### 继承实现\n```javascript\nfunction Student(name, grade) {\n  Person.call(this, name);\n  this.grade = grade;\n}\n\nStudent.prototype = Object.create(Person.prototype);\nStudent.prototype.constructor = Student;\n```\n\n### ES6 Class\n```javascript\nclass Person {\n  constructor(name) {\n    this.name = name;\n  }\n  sayHello() {\n    console.log(`Hello, I am ${this.name}`);\n  }\n}\n```\n\n### 注意事项\n- 理解原型链有助于理解 JavaScript 继承\n- 避免修改内置对象的原型\n- 使用 `Object.create()` 创建对象",
    "id": 88,
    "hash": "e0252033e59376a2b78806863c7a1257"
  },
  "89": {
    "title": "防抖和节流 (8)",
    "createdAt": 1711670400000,
    "content": "## 防抖和节流\n\n防抖（debounce）和节流（throttle）是限制函数执行频率的两种技术。\n\n### 防抖（Debounce）\n在事件被触发 n 秒后再执行回调，如果在这 n 秒内又被触发，则重新计时。\n\n```javascript\nfunction debounce(func, delay) {\n  let timeoutId;\n  return function(...args) {\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(() => func.apply(this, args), delay);\n  };\n}\n\n// 使用\nconst handleInput = debounce((e) => {\n  console.log(e.target.value);\n}, 300);\n```\n\n### 节流（Throttle）\n规定在一个单位时间内，只能触发一次函数。\n\n```javascript\nfunction throttle(func, delay) {\n  let lastTime = 0;\n  return function(...args) {\n    const now = Date.now();\n    if (now - lastTime >= delay) {\n      lastTime = now;\n      func.apply(this, args);\n    }\n  };\n}\n```\n\n### 使用场景\n- **防抖**: 搜索框输入、窗口 resize\n- **节流**: 滚动事件、鼠标移动\n\n### React Hooks 实现\n```javascript\nfunction useDebounce(value, delay) {\n  const [debouncedValue, setDebouncedValue] = useState(value);\n  useEffect(() => {\n    const handler = setTimeout(() => setDebouncedValue(value), delay);\n    return () => clearTimeout(handler);\n  }, [value, delay]);\n  return debouncedValue;\n}\n```",
    "id": 89,
    "hash": "41c6d7e1e081ed93def10f138c4994b7"
  },
  "90": {
    "title": "CSS 变量（Custom Properties） (8)",
    "createdAt": 1711756800000,
    "content": "## CSS 变量（Custom Properties）\n\nCSS 变量允许在样式表中定义可重用的值，提高样式的可维护性。\n\n### 定义变量\n```css\n:root {\n  --primary-color: #3498db;\n  --secondary-color: #2ecc71;\n  --font-size-base: 16px;\n  --spacing-unit: 8px;\n}\n```\n\n### 使用变量\n```css\n.button {\n  background-color: var(--primary-color);\n  font-size: var(--font-size-base);\n  padding: calc(var(--spacing-unit) * 2);\n}\n```\n\n### JavaScript 操作\n```javascript\n// 获取变量值\nconst primaryColor = getComputedStyle(document.documentElement)\n  .getPropertyValue(\"--primary-color\");\n\n// 设置变量值\ndocument.documentElement.style.setProperty(\"--primary-color\", \"#ff0000\");\n```\n\n### 优势\n- 主题切换\n- 动态样式\n- 减少重复代码\n- 易于维护\n\n### 作用域\n- `:root`: 全局作用域\n- 元素选择器: 局部作用域\n- 继承性: 子元素可以继承父元素的变量",
    "id": 90,
    "hash": "e9107963d8f1f18023c659382b948d06"
  },
  "91": {
    "title": "React 组件生命周期 (8)",
    "createdAt": 1711843200000,
    "content": "## React 组件生命周期\n\nReact 组件的生命周期分为三个阶段：挂载、更新和卸载。\n\n### 类组件生命周期\n```javascript\nclass MyComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    // 初始化状态\n  }\n  \n  componentDidMount() {\n    // 组件挂载后\n  }\n  \n  componentDidUpdate(prevProps, prevState) {\n    // 组件更新后\n  }\n  \n  componentWillUnmount() {\n    // 组件卸载前\n  }\n}\n```\n\n### 函数组件等效\n```javascript\nuseEffect(() => {\n  // componentDidMount + componentDidUpdate\n  return () => {\n    // componentWillUnmount\n  };\n}, [dependencies]);\n```\n\n### 生命周期阶段\n- **挂载**: constructor → render → componentDidMount\n- **更新**: render → componentDidUpdate\n- **卸载**: componentWillUnmount\n\n### 注意事项\n- 函数组件使用 Hooks 替代生命周期\n- 避免在 render 中执行副作用\n- 及时清理订阅和定时器",
    "id": 91,
    "hash": "c96346cee1432253c6e65ce08e631af8"
  },
  "92": {
    "title": "Vue 组件通信 (8)",
    "createdAt": 1711929600000,
    "content": "## Vue 组件通信\n\nVue 组件间有多种通信方式，适用于不同的场景。\n\n### Props 和 Events\n```vue\n<!-- 父组件 -->\n<ChildComponent :data=\"parentData\" @update=\"handleUpdate\" />\n\n<!-- 子组件 -->\n<template>\n  <div @click=\"$emit('update', newData)\">\n    {{ data }}\n  </div>\n</template>\n<script>\nexport default {\n  props: ['data'],\n  emits: ['update']\n}\n</script>\n```\n\n### provide/inject\n```javascript\n// 祖先组件\nprovide() {\n  return {\n    theme: this.theme\n  }\n}\n\n// 后代组件\ninject: ['theme']\n```\n\n### Vuex/Pinia\n- 全局状态管理\n- 跨组件共享数据\n\n### 事件总线（已废弃）\n- 使用全局事件总线\n- Vue 3 推荐使用 mitt 库\n\n### 最佳实践\n- 父子组件用 props/events\n- 跨层级用 provide/inject\n- 全局状态用状态管理",
    "id": 92,
    "hash": "d255264c44fe4ab6d638ce391536f8eb"
  },
  "93": {
    "title": "Babel 转译原理 (8)",
    "createdAt": 1712016000000,
    "content": "## Babel 转译原理\n\nBabel 是一个 JavaScript 编译器，将 ES6+ 代码转换为向后兼容的 JavaScript 版本。\n\n### 工作流程\n1. **解析（Parse）**: 将代码转换为 AST\n2. **转换（Transform）**: 对 AST 进行操作\n3. **生成（Generate）**: 将 AST 转换为代码\n\n### 核心概念\n- **AST（抽象语法树）**: 代码的树形表示\n- **Plugin**: 转换规则\n- **Preset**: 插件集合\n\n### 配置示例\n```json\n{\n  \"presets\": [\"@babel/preset-env\"],\n  \"plugins\": [\"@babel/plugin-proposal-class-properties\"]\n}\n```\n\n### 常用 Preset\n- `@babel/preset-env`: 根据目标环境转换\n- `@babel/preset-react`: React 语法转换\n- `@babel/preset-typescript`: TypeScript 转换\n\n### Polyfill\n- `@babel/polyfill`: 已废弃\n- `core-js`: 提供 polyfill\n- `regenerator-runtime`: async/await 支持",
    "id": 93,
    "hash": "5f4f96039735ed7bcffb30199bdb45fc"
  },
  "94": {
    "title": "ESLint 代码检查 (8)",
    "createdAt": 1712102400000,
    "content": "## ESLint 代码检查\n\nESLint 是一个可插拔的 JavaScript 代码检查工具，用于发现和修复代码问题。\n\n### 配置文件\n```json\n{\n  \"extends\": [\"eslint:recommended\"],\n  \"rules\": {\n    \"no-console\": \"warn\",\n    \"no-unused-vars\": \"error\"\n  }\n}\n```\n\n### 常用规则\n- `no-console`: 禁止使用 console\n- `no-unused-vars`: 禁止未使用的变量\n- `eqeqeq`: 要求使用 === 和 !==\n- `semi`: 要求或禁止分号\n\n### 与 Prettier 集成\n```json\n{\n  \"extends\": [\n    \"eslint:recommended\",\n    \"plugin:prettier/recommended\"\n  ]\n}\n```\n\n### 优势\n- 统一代码风格\n- 提前发现错误\n- 提高代码质量\n- 团队协作规范",
    "id": 94,
    "hash": "ec767a78fce20578126f4664d6feb288"
  },
  "95": {
    "title": "Git 工作流 (8)",
    "createdAt": 1712188800000,
    "content": "## Git 工作流\n\nGit 是分布式版本控制系统，用于跟踪代码变更。\n\n### 基本命令\n```bash\ngit add .          # 暂存更改\ngit commit -m \"msg\" # 提交更改\ngit push           # 推送到远程\ngit pull           # 拉取更新\ngit branch         # 查看分支\ngit merge          # 合并分支\n```\n\n### 工作流模型\n- **Git Flow**: 功能分支、发布分支\n- **GitHub Flow**: 简化的工作流\n- **GitLab Flow**: 带环境分支\n\n### 最佳实践\n- 频繁提交小改动\n- 写清晰的提交信息\n- 使用分支开发\n- 代码审查\n\n### 常用场景\n- 功能开发: feature 分支\n- 修复 bug: hotfix 分支\n- 发布版本: release 分支",
    "id": 95,
    "hash": "56ca52be775c7acab1ca762afdec06b5"
  },
  "96": {
    "title": "CSS Grid 布局 (9)",
    "createdAt": 1712275200000,
    "content": "## CSS Grid 布局\n\nCSS Grid 是二维布局系统，可以同时处理行和列。它是 Flexbox 的补充，适合复杂的网格布局。\n\n### 基本概念\n- **Grid 容器**: 使用 `display: grid` 创建网格容器\n- **Grid 项目**: 容器内的直接子元素\n- **网格线**: 网格的分割线\n- **网格轨道**: 两条网格线之间的空间\n\n### 容器属性\n```css\n.grid-container {\n  display: grid;\n  grid-template-columns: repeat(3, 1fr);\n  grid-template-rows: auto;\n  gap: 20px;\n}\n```\n\n### 项目属性\n- `grid-column`: 指定项目占据的列\n- `grid-row`: 指定项目占据的行\n- `grid-area`: 指定项目占据的区域\n\n### 适用场景\n- 复杂的二维布局\n- 响应式网格系统\n- 卡片网格布局\n- 页面整体布局",
    "id": 96,
    "hash": "00d5866845c7ae0e39854f663c2de713"
  },
  "97": {
    "title": "Promise 和异步编程 (9)",
    "createdAt": 1712361600000,
    "content": "## Promise 和异步编程\n\nPromise 是 JavaScript 中处理异步操作的对象，它代表一个异步操作的最终完成或失败。\n\n### 基本用法\n```javascript\nconst promise = new Promise((resolve, reject) => {\n  // 异步操作\n  if (success) {\n    resolve(value);\n  } else {\n    reject(error);\n  }\n});\n\npromise.then(value => {\n  // 成功处理\n}).catch(error => {\n  // 错误处理\n});\n```\n\n### Promise 方法\n- `Promise.all()`: 所有 Promise 都成功\n- `Promise.race()`: 第一个完成的 Promise\n- `Promise.allSettled()`: 等待所有 Promise 完成\n- `Promise.any()`: 第一个成功的 Promise\n\n### async/await\n```javascript\nasync function fetchData() {\n  try {\n    const data = await fetch(url);\n    return data.json();\n  } catch (error) {\n    console.error(error);\n  }\n}\n```\n\n### 优势\n- 避免回调地狱\n- 更好的错误处理\n- 链式调用\n- 代码更易读",
    "id": 97,
    "hash": "58b7bc29e7f233cafa33b72cebb332bb"
  },
  "98": {
    "title": "JavaScript 原型链 (9)",
    "createdAt": 1712448000000,
    "content": "## JavaScript 原型链\n\n原型链是 JavaScript 实现继承的机制。每个对象都有一个指向其原型对象的内部链接。\n\n### 原型对象\n```javascript\nfunction Person(name) {\n  this.name = name;\n}\n\nPerson.prototype.sayHello = function() {\n  console.log(`Hello, I am ${this.name}`);\n};\n\nconst person = new Person(\"Alice\");\nperson.sayHello(); // 通过原型链访问\n```\n\n### 原型链查找\n1. 对象自身属性\n2. 对象的 `__proto__` 指向的原型\n3. 原型的原型，直到 `Object.prototype`\n4. `Object.prototype.__proto__` 为 `null`\n\n### 继承实现\n```javascript\nfunction Student(name, grade) {\n  Person.call(this, name);\n  this.grade = grade;\n}\n\nStudent.prototype = Object.create(Person.prototype);\nStudent.prototype.constructor = Student;\n```\n\n### ES6 Class\n```javascript\nclass Person {\n  constructor(name) {\n    this.name = name;\n  }\n  sayHello() {\n    console.log(`Hello, I am ${this.name}`);\n  }\n}\n```\n\n### 注意事项\n- 理解原型链有助于理解 JavaScript 继承\n- 避免修改内置对象的原型\n- 使用 `Object.create()` 创建对象",
    "id": 98,
    "hash": "0b8694d0feb910ea54d3c5d86e1e1544"
  },
  "99": {
    "title": "防抖和节流 (9)",
    "createdAt": 1712534400000,
    "content": "## 防抖和节流\n\n防抖（debounce）和节流（throttle）是限制函数执行频率的两种技术。\n\n### 防抖（Debounce）\n在事件被触发 n 秒后再执行回调，如果在这 n 秒内又被触发，则重新计时。\n\n```javascript\nfunction debounce(func, delay) {\n  let timeoutId;\n  return function(...args) {\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(() => func.apply(this, args), delay);\n  };\n}\n\n// 使用\nconst handleInput = debounce((e) => {\n  console.log(e.target.value);\n}, 300);\n```\n\n### 节流（Throttle）\n规定在一个单位时间内，只能触发一次函数。\n\n```javascript\nfunction throttle(func, delay) {\n  let lastTime = 0;\n  return function(...args) {\n    const now = Date.now();\n    if (now - lastTime >= delay) {\n      lastTime = now;\n      func.apply(this, args);\n    }\n  };\n}\n```\n\n### 使用场景\n- **防抖**: 搜索框输入、窗口 resize\n- **节流**: 滚动事件、鼠标移动\n\n### React Hooks 实现\n```javascript\nfunction useDebounce(value, delay) {\n  const [debouncedValue, setDebouncedValue] = useState(value);\n  useEffect(() => {\n    const handler = setTimeout(() => setDebouncedValue(value), delay);\n    return () => clearTimeout(handler);\n  }, [value, delay]);\n  return debouncedValue;\n}\n```",
    "id": 99,
    "hash": "02de10d7a22f080d7f623a8c04e6ded4"
  },
  "100": {
    "title": "CSS 变量（Custom Properties） (9)",
    "createdAt": 1712620800000,
    "content": "## CSS 变量（Custom Properties）\n\nCSS 变量允许在样式表中定义可重用的值，提高样式的可维护性。\n\n### 定义变量\n```css\n:root {\n  --primary-color: #3498db;\n  --secondary-color: #2ecc71;\n  --font-size-base: 16px;\n  --spacing-unit: 8px;\n}\n```\n\n### 使用变量\n```css\n.button {\n  background-color: var(--primary-color);\n  font-size: var(--font-size-base);\n  padding: calc(var(--spacing-unit) * 2);\n}\n```\n\n### JavaScript 操作\n```javascript\n// 获取变量值\nconst primaryColor = getComputedStyle(document.documentElement)\n  .getPropertyValue(\"--primary-color\");\n\n// 设置变量值\ndocument.documentElement.style.setProperty(\"--primary-color\", \"#ff0000\");\n```\n\n### 优势\n- 主题切换\n- 动态样式\n- 减少重复代码\n- 易于维护\n\n### 作用域\n- `:root`: 全局作用域\n- 元素选择器: 局部作用域\n- 继承性: 子元素可以继承父元素的变量",
    "id": 100,
    "hash": "e1394b8e8255849cab10ad1f809b4bd0"
  }
}